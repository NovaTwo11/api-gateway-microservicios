{
  "version": "1.0",
  "records": [
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/ApiGatewayApplication.java",
      "timestamp": 1763017605929,
      "startOffset": 0,
      "endOffset": 75,
      "codeContent": "package co.edu.uniquindio.gateway;\n\npublic class ApiGatewayApplication {\n}\n",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 5
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/ApiGatewayApplication.java",
      "timestamp": 1763017610498,
      "startOffset": 36,
      "endOffset": 505,
      "codeContent": "import org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n\n@SpringBootApplication\n@EnableDiscoveryClient // Habilita el descubrimiento de servicios (aunque usemos el de Docker)\npublic class ApiGatewayApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ApiGatewayApplication.class, args);\n    }\n\n}",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 13
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/config/TestConfig.java",
      "timestamp": 1763021572511,
      "startOffset": 2547,
      "endOffset": 2809,
      "codeContent": "/** URL completa del endpoint /token del realm MASTER */\n    public String getMasterTokenUrl() {\n        // Usa \"master\" en lugar de keycloakRealm\n        return String.format(\"%s/realms/master/protocol/openid-connect/token\",\n                keycloakUrl); \n    }",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 6
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/TokenClient.java",
      "timestamp": 1763021672919,
      "startOffset": 3726,
      "endOffset": 6231,
      "codeContent": "String cacheKey \u003d \"admin_master_token\"; // Clave de caché específica para el admin\n        TokenInfo tokenInfo \u003d tokenCache.get(cacheKey);\n\n        // Si el token de admin existe y NO ha expirado, lo usamos\n        if (tokenInfo !\u003d null \u0026\u0026 !tokenInfo.isExpired()) {\n            log.debug(\"Reutilizando token de admin en caché\");\n            return tokenInfo.getAccessToken();\n        }\n\n        // Si no hay token o expiró, pedimos uno nuevo AL REALM MASTER\n        log.debug(\"Solicitando nuevo token de admin al realm \u0027master\u0027\");\n        String newToken;\n        int expiresIn \u003d 240; // fallback\n\n        try {\n            // 1. Obtenemos la URL del realm \u0027master\u0027 (del TestConfig)\n            String masterTokenUrl \u003d config.getMasterTokenUrl();\n\n            // 2. Llamamos al método SOBRECARGADO de AuthClient\n            Response response \u003d authClient.requestTokenResponse(\n                    config.getAdminUsername(),\n                    config.getAdminPassword(),\n                    masterTokenUrl // \u003c-- ¡La URL explícita del realm \u0027master\u0027!\n            );\n\n            if (response.statusCode() \u003d\u003d 200) {\n                newToken \u003d response.jsonPath().getString(\"access_token\");\n                Integer exp \u003d response.jsonPath().getInt(\"expires_in\");\n\n                if (exp !\u003d null \u0026\u0026 exp \u003e 0) {\n                    expiresIn \u003d exp;\n                }\n\n                // Guardar el token de admin en caché\n                tokenCache.put(cacheKey, new TokenInfo(newToken, expiresIn));\n                log.debug(\"Nuevo token de ADMIN guardado en caché (expira en {}s)\", expiresIn);\n                return newToken;\n            } else {\n                // Manejar error de autenticación (ej. 401 Unauthorized)\n                log.error(\"¡FALLO CRÍTICO! No se pudo obtener el token de administrador.\");\n                log.error(\"El realm \u0027master\u0027 de Keycloak en {} respondió con status {}. Body: {}\",\n                        masterTokenUrl, response.statusCode(), response.getBody().asString());\n                log.error(\"Verifica las credenciales \u0027admin.username\u0027 y \u0027admin.password\u0027 en test.properties y que Keycloak esté corriendo.\");\n                throw new RuntimeException(\"No se pudo obtener el token de administrador. Revisa la configuración.\");\n            }\n        } catch (Exception e) {\n            log.error(\"Error al solicitar token de admin: {}\", e.getMessage());\n            throw new RuntimeException(\"Error al comunicarse con Keycloak (master): \" + e.getMessage());\n        }",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 49
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/AuthClient.java",
      "timestamp": 1763021687648,
      "startOffset": 140,
      "endOffset": 4587,
      "codeContent": "io.restassured.http.ContentType; // Importa ContentType\nimport lombok.extern.slf4j.Slf4j;\n\nimport static io.restassured.RestAssured.given;\n\n/**\n * Cliente encargado de manejar la autenticación y obtener información del usuario\n * desde Keycloak (u otro servidor compatible con OpenID Connect).\n */\n@Slf4j\npublic class AuthClient {\n\n    private static AuthClient instance;\n\n    // Estos son los valores por DEFECTO (para el realm \u0027taller\u0027)\n    private final String defaultTokenUrl;\n    private final String clientId;\n    private final String clientSecret;\n    private final String userInfoUrl;\n\n    private AuthClient() {\n        TestConfig config \u003d TestConfig.getInstance();\n        // Renombrado de tokenUrl a defaultTokenUrl para mayor claridad\n        this.defaultTokenUrl \u003d config.getKeycloakTokenUrl(); \n        this.clientId \u003d config.getKeycloakClientId();\n        this.clientSecret \u003d config.getKeycloakClientSecret();\n        this.userInfoUrl \u003d config.getKeycloakUserInfoUrl();\n    }\n\n    public static AuthClient getInstance() {\n        if (instance \u003d\u003d null) {\n            synchronized (AuthClient.class) {\n                if (instance \u003d\u003d null) {\n                    instance \u003d new AuthClient();\n                }\n            }\n        }\n        return instance;\n    }\n\n    /**\n     * --- MÉTODO ANTIGUO (MODIFICADO) ---\n     * Realiza la petición al token endpoint POR DEFECTO (realm \u0027taller\u0027).\n     * Ahora delega la llamada al nuevo método sobrecargado.\n     */\n    public Response requestTokenResponse(String username, String password) {\n        log.debug(\"Solicitando token (por defecto) para user\u003d{}\", username);\n        // Llama al método de trabajo principal usando la URL por defecto\n        return requestTokenResponse(username, password, this.defaultTokenUrl);\n    }\n\n    /**\n     * --- MÉTODO NUEVO (SOBRECARGADO) ---\n     * Esta es la corrección clave.\n     * Realiza la petición al token endpoint en una URL ESPECÍFICA.\n     * Lo usaremos para llamar al realm \u0027master\u0027 cuando pidamos el token de admin.\n     */\n    public Response requestTokenResponse(String username, String password, String specificTokenUrl) {\n        log.debug(\"Solicitando token para user\u003d{} en URL\u003d{}\", username, specificTokenUrl);\n\n        Response response \u003d given()\n                // Corregido: RestAssured recomienda ContentType.URLENC\n                .contentType(ContentType.URLENC) \n                .formParam(\"grant_type\", \"password\")\n                .formParam(\"client_id\", clientId)\n                .formParam(\"client_secret\", clientSecret)\n                .formParam(\"username\", username)\n                .formParam(\"password\", password)\n                .when()\n                .post(specificTokenUrl); // \u003c-- Usa la URL específica\n\n        log.debug(\"Token endpoint → status\u003d{} body\u003d{}\",\n                response.statusCode(), safeBody(response));\n\n        return response;\n    }\n\n\n    /**\n     * Obtiene el access_token y lanza excepción si la respuesta no es exitosa.\n     * (Este método no cambia, seguirá usando el realm por defecto \u0027taller\u0027)\n     */\n    public String getAccessToken(String username, String password) {\n        Response r \u003d requestTokenResponse(username, password); // Llama al método por defecto\n        if (r.statusCode() !\u003d 200) {\n            log.error(\"Error obteniendo token. Status: {}, Body: {}\", r.statusCode(), safeBody(r));\n            throw new RuntimeException(\"No se pudo obtener el token de acceso. Status: \" + r.statusCode());\n        }\n        String token \u003d r.jsonPath().getString(\"access_token\");\n        log.debug(\"Token obtenido correctamente para {} ({} caracteres)\", username, token !\u003d null ? token.length() : 0);\n        return token;\n    }\n\n    /**\n     * Llama al endpoint userinfo con el token proporcionado.\n     * (Este método no cambia)\n     */\n    public Response getUserInfo(String accessToken) {\n        log.debug(\"Llamando al endpoint userinfo\");\n        Response response \u003d given()\n                .header(\"Authorization\", \"Bearer \" + accessToken)\n                .when()\n                .get(userInfoUrl);\n\n        log.debug(\"Userinfo → status\u003d{} body\u003d{}\", response.statusCode(), safeBody(response));\n        return response;\n    }\n\n    private String safeBody(Response response) {\n        try {\n            return response.getBody() !\u003d null ? response.getBody().asString() : \"(sin cuerpo)\";\n        } catch (Exception e) {\n            return \"(error leyendo body)\";\n        }\n    }\n}",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 116
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/config/TestConfig.java",
      "timestamp": 1763021986753,
      "startOffset": 555,
      "endOffset": 590,
      "codeContent": "private final String adminClientId;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/config/TestConfig.java",
      "timestamp": 1763022049686,
      "startOffset": 4054,
      "endOffset": 4126,
      "codeContent": "public java.lang.String getAdminPassword() {\n    return adminPassword;\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 3
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/config/TestConfig.java",
      "timestamp": 1763022049701,
      "startOffset": 4116,
      "endOffset": 4188,
      "codeContent": "public java.lang.String getAdminUsername() {\n    return adminUsername;\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 3
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/config/TestConfig.java",
      "timestamp": 1763022049715,
      "startOffset": 4178,
      "endOffset": 4264,
      "codeContent": "public java.lang.String getKeycloakClientSecret() {\n    return keycloakClientSecret;\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 3
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/config/TestConfig.java",
      "timestamp": 1763022049728,
      "startOffset": 4254,
      "endOffset": 4332,
      "codeContent": "public java.lang.String getKeycloakClientId() {\n    return keycloakClientId;\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 3
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/config/TestConfig.java",
      "timestamp": 1763022049741,
      "startOffset": 4322,
      "endOffset": 4394,
      "codeContent": "public java.lang.String getKeycloakRealm() {\n    return keycloakRealm;\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 3
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/config/TestConfig.java",
      "timestamp": 1763022049755,
      "startOffset": 4384,
      "endOffset": 4452,
      "codeContent": "public java.lang.String getKeycloakUrl() {\n    return keycloakUrl;\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 3
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/config/TestConfig.java",
      "timestamp": 1763022049770,
      "startOffset": 4442,
      "endOffset": 4508,
      "codeContent": "public java.lang.String getApiBaseUrl() {\n    return apiBaseUrl;\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 3
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/config/TestConfig.java",
      "timestamp": 1763022049784,
      "startOffset": 4498,
      "endOffset": 4568,
      "codeContent": "public java.util.Properties getProperties() {\n    return properties;\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 3
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/config/TestConfig.java",
      "timestamp": 1763022049796,
      "startOffset": 4558,
      "endOffset": 4680,
      "codeContent": "public static void setInstance(co.edu.uniquindio.tests.config.TestConfig instance) {\n    TestConfig.instance \u003d instance;\n}",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 3
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/AuthClient.java",
      "timestamp": 1763022145002,
      "startOffset": 231,
      "endOffset": 252,
      "codeContent": "import java.util.Map;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/AuthClient.java",
      "timestamp": 1763022147648,
      "startOffset": 231,
      "endOffset": 256,
      "codeContent": "import java.util.HashMap;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/AuthClient.java",
      "timestamp": 1763022220673,
      "startOffset": 512,
      "endOffset": 2875,
      "codeContent": "\n    // Estos son los valores por DEFECTO (para el realm \u0027taller\u0027)\n    private final String defaultTokenUrl;\n    private final String clientId;\n    private final String clientSecret;\n    private final String userInfoUrl;\n\n    private AuthClient() {\n        TestConfig config \u003d TestConfig.getInstance();\n        // Renombrado de tokenUrl a defaultTokenUrl para mayor claridad\n        this.defaultTokenUrl \u003d config.getKeycloakTokenUrl();\n        this.clientId \u003d config.getKeycloakClientId();\n        this.clientSecret \u003d config.getKeycloakClientSecret();\n        this.userInfoUrl \u003d config.getKeycloakUserInfoUrl();\n    }\n\n    public static AuthClient getInstance() {\n        if (instance \u003d\u003d null) {\n            synchronized (AuthClient.class) {\n                if (instance \u003d\u003d null) {\n                    instance \u003d new AuthClient();\n                }\n            }\n        }\n        return instance;\n    }\n\n    /**\n     * --- MÉTODO ANTIGUO (MODIFICADO) ---\n     * Realiza la petición al token endpoint POR DEFECTO (realm \u0027taller\u0027).\n     * Ahora delega la llamada al nuevo método sobrecargado.\n     */\n    public Response requestTokenResponse(String username, String password) {\n        log.debug(\"Solicitando token (por defecto) para user\u003d{}\", username);\n        // Llama al método de trabajo principal usando la URL por defecto\n        return requestTokenResponse(username, password, this.defaultTokenUrl);\n    }\n\n    /**\n     * --- MÉTODO NUEVO (SOBRECARGADO) ---\n     * Esta es la corrección clave.\n     * Realiza la petición al token endpoint en una URL ESPECÍFICA.\n     * Lo usaremos para llamar al realm \u0027master\u0027 cuando pidamos el token de admin.\n     */\n    public Response requestTokenResponse(String username, String password, String specificTokenUrl) {\n        log.debug(\"Solicitando token para user\u003d{} en URL\u003d{}\", username, specificTokenUrl);\n\n        Response response \u003d given()\n                // Corregido: RestAssured recomienda ContentType.URLENC\n                .contentType(ContentType.URLENC)\n                .formParam(\"grant_type\", \"password\")\n                .formParam(\"client_id\", clientId)\n                .formParam(\"client_secret\", clientSecret)\n                .formParam(\"username\", username)\n                .formParam(\"password\", password)\n                .when()\n                .post(specificTokenUrl); // \u003c-- Usa la URL específica",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 57
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/AuthClient.java",
      "timestamp": 1763022225233,
      "startOffset": 512,
      "endOffset": 2875,
      "codeContent": "\n    // Estos son los valores por DEFECTO (para el realm \u0027taller\u0027)\n    private final String defaultTokenUrl;\n    private final String clientId;\n    private final String clientSecret;\n    private final String userInfoUrl;\n\n    private AuthClient() {\n        TestConfig config \u003d TestConfig.getInstance();\n        // Renombrado de tokenUrl a defaultTokenUrl para mayor claridad\n        this.defaultTokenUrl \u003d config.getKeycloakTokenUrl();\n        this.clientId \u003d config.getKeycloakClientId();\n        this.clientSecret \u003d config.getKeycloakClientSecret();\n        this.userInfoUrl \u003d config.getKeycloakUserInfoUrl();\n    }\n\n    public static AuthClient getInstance() {\n        if (instance \u003d\u003d null) {\n            synchronized (AuthClient.class) {\n                if (instance \u003d\u003d null) {\n                    instance \u003d new AuthClient();\n                }\n            }\n        }\n        return instance;\n    }\n\n    /**\n     * --- MÉTODO ANTIGUO (MODIFICADO) ---\n     * Realiza la petición al token endpoint POR DEFECTO (realm \u0027taller\u0027).\n     * Ahora delega la llamada al nuevo método sobrecargado.\n     */\n    public Response requestTokenResponse(String username, String password) {\n        log.debug(\"Solicitando token (por defecto) para user\u003d{}\", username);\n        // Llama al método de trabajo principal usando la URL por defecto\n        return requestTokenResponse(username, password, this.defaultTokenUrl);\n    }\n\n    /**\n     * --- MÉTODO NUEVO (SOBRECARGADO) ---\n     * Esta es la corrección clave.\n     * Realiza la petición al token endpoint en una URL ESPECÍFICA.\n     * Lo usaremos para llamar al realm \u0027master\u0027 cuando pidamos el token de admin.\n     */\n    public Response requestTokenResponse(String username, String password, String specificTokenUrl) {\n        log.debug(\"Solicitando token para user\u003d{} en URL\u003d{}\", username, specificTokenUrl);\n\n        Response response \u003d given()\n                // Corregido: RestAssured recomienda ContentType.URLENC\n                .contentType(ContentType.URLENC)\n                .formParam(\"grant_type\", \"password\")\n                .formParam(\"client_id\", clientId)\n                .formParam(\"client_secret\", clientSecret)\n                .formParam(\"username\", username)\n                .formParam(\"password\", password)\n                .when()\n                .post(specificTokenUrl); // \u003c-- Usa la URL específica",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 57
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/AuthClient.java",
      "timestamp": 1763022228273,
      "startOffset": 512,
      "endOffset": 2875,
      "codeContent": "\n    // Estos son los valores por DEFECTO (para el realm \u0027taller\u0027)\n    private final String defaultTokenUrl;\n    private final String clientId;\n    private final String clientSecret;\n    private final String userInfoUrl;\n\n    private AuthClient() {\n        TestConfig config \u003d TestConfig.getInstance();\n        // Renombrado de tokenUrl a defaultTokenUrl para mayor claridad\n        this.defaultTokenUrl \u003d config.getKeycloakTokenUrl();\n        this.clientId \u003d config.getKeycloakClientId();\n        this.clientSecret \u003d config.getKeycloakClientSecret();\n        this.userInfoUrl \u003d config.getKeycloakUserInfoUrl();\n    }\n\n    public static AuthClient getInstance() {\n        if (instance \u003d\u003d null) {\n            synchronized (AuthClient.class) {\n                if (instance \u003d\u003d null) {\n                    instance \u003d new AuthClient();\n                }\n            }\n        }\n        return instance;\n    }\n\n    /**\n     * --- MÉTODO ANTIGUO (MODIFICADO) ---\n     * Realiza la petición al token endpoint POR DEFECTO (realm \u0027taller\u0027).\n     * Ahora delega la llamada al nuevo método sobrecargado.\n     */\n    public Response requestTokenResponse(String username, String password) {\n        log.debug(\"Solicitando token (por defecto) para user\u003d{}\", username);\n        // Llama al método de trabajo principal usando la URL por defecto\n        return requestTokenResponse(username, password, this.defaultTokenUrl);\n    }\n\n    /**\n     * --- MÉTODO NUEVO (SOBRECARGADO) ---\n     * Esta es la corrección clave.\n     * Realiza la petición al token endpoint en una URL ESPECÍFICA.\n     * Lo usaremos para llamar al realm \u0027master\u0027 cuando pidamos el token de admin.\n     */\n    public Response requestTokenResponse(String username, String password, String specificTokenUrl) {\n        log.debug(\"Solicitando token para user\u003d{} en URL\u003d{}\", username, specificTokenUrl);\n\n        Response response \u003d given()\n                // Corregido: RestAssured recomienda ContentType.URLENC\n                .contentType(ContentType.URLENC)\n                .formParam(\"grant_type\", \"password\")\n                .formParam(\"client_id\", clientId)\n                .formParam(\"client_secret\", clientSecret)\n                .formParam(\"username\", username)\n                .formParam(\"password\", password)\n                .when()\n                .post(specificTokenUrl); // \u003c-- Usa la URL específica",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 57
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/AuthClient.java",
      "timestamp": 1763022232154,
      "startOffset": 512,
      "endOffset": 2875,
      "codeContent": "\n    // Estos son los valores por DEFECTO (para el realm \u0027taller\u0027)\n    private final String defaultTokenUrl;\n    private final String clientId;\n    private final String clientSecret;\n    private final String userInfoUrl;\n\n    private AuthClient() {\n        TestConfig config \u003d TestConfig.getInstance();\n        // Renombrado de tokenUrl a defaultTokenUrl para mayor claridad\n        this.defaultTokenUrl \u003d config.getKeycloakTokenUrl();\n        this.clientId \u003d config.getKeycloakClientId();\n        this.clientSecret \u003d config.getKeycloakClientSecret();\n        this.userInfoUrl \u003d config.getKeycloakUserInfoUrl();\n    }\n\n    public static AuthClient getInstance() {\n        if (instance \u003d\u003d null) {\n            synchronized (AuthClient.class) {\n                if (instance \u003d\u003d null) {\n                    instance \u003d new AuthClient();\n                }\n            }\n        }\n        return instance;\n    }\n\n    /**\n     * --- MÉTODO ANTIGUO (MODIFICADO) ---\n     * Realiza la petición al token endpoint POR DEFECTO (realm \u0027taller\u0027).\n     * Ahora delega la llamada al nuevo método sobrecargado.\n     */\n    public Response requestTokenResponse(String username, String password) {\n        log.debug(\"Solicitando token (por defecto) para user\u003d{}\", username);\n        // Llama al método de trabajo principal usando la URL por defecto\n        return requestTokenResponse(username, password, this.defaultTokenUrl);\n    }\n\n    /**\n     * --- MÉTODO NUEVO (SOBRECARGADO) ---\n     * Esta es la corrección clave.\n     * Realiza la petición al token endpoint en una URL ESPECÍFICA.\n     * Lo usaremos para llamar al realm \u0027master\u0027 cuando pidamos el token de admin.\n     */\n    public Response requestTokenResponse(String username, String password, String specificTokenUrl) {\n        log.debug(\"Solicitando token para user\u003d{} en URL\u003d{}\", username, specificTokenUrl);\n\n        Response response \u003d given()\n                // Corregido: RestAssured recomienda ContentType.URLENC\n                .contentType(ContentType.URLENC)\n                .formParam(\"grant_type\", \"password\")\n                .formParam(\"client_id\", clientId)\n                .formParam(\"client_secret\", clientSecret)\n                .formParam(\"username\", username)\n                .formParam(\"password\", password)\n                .when()\n                .post(specificTokenUrl); // \u003c-- Usa la URL específica",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 57
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/AuthClient.java",
      "timestamp": 1763022268567,
      "startOffset": 231,
      "endOffset": 252,
      "codeContent": "import java.util.Map;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/AuthClient.java",
      "timestamp": 1763022270072,
      "startOffset": 231,
      "endOffset": 256,
      "codeContent": "import java.util.HashMap;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "/AuthClient.java",
      "timestamp": 1763022296496,
      "startOffset": 843,
      "endOffset": 891,
      "codeContent": "co.edu.uniquindio.tests.config.TestConfig config",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "/AuthClient.java",
      "timestamp": 1763022296503,
      "startOffset": 863,
      "endOffset": 884,
      "codeContent": "this.config \u003d config;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/AuthClient.java",
      "timestamp": 1763022296526,
      "startOffset": 863,
      "endOffset": 893,
      "codeContent": "\n        this.config \u003d config;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 2
    },
    {
      "filePath": "/_Dummy_.java",
      "timestamp": 1763022300377,
      "startOffset": 38,
      "endOffset": 86,
      "codeContent": "co.edu.uniquindio.tests.config.TestConfig config",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/AuthClient.java",
      "timestamp": 1763022381089,
      "startOffset": 140,
      "endOffset": 4587,
      "codeContent": "io.restassured.http.ContentType; // Importa ContentType\nimport lombok.extern.slf4j.Slf4j;\n\nimport static io.restassured.RestAssured.given;\n\n/**\n * Cliente encargado de manejar la autenticación y obtener información del usuario\n * desde Keycloak (u otro servidor compatible con OpenID Connect).\n */\n@Slf4j\npublic class AuthClient {\n\n    private static AuthClient instance;\n\n    // Estos son los valores por DEFECTO (para el realm \u0027taller\u0027)\n    private final String defaultTokenUrl;\n    private final String clientId;\n    private final String clientSecret;\n    private final String userInfoUrl;\n\n    private AuthClient() {\n        TestConfig config \u003d TestConfig.getInstance();\n        // Renombrado de tokenUrl a defaultTokenUrl para mayor claridad\n        this.defaultTokenUrl \u003d config.getKeycloakTokenUrl(); \n        this.clientId \u003d config.getKeycloakClientId();\n        this.clientSecret \u003d config.getKeycloakClientSecret();\n        this.userInfoUrl \u003d config.getKeycloakUserInfoUrl();\n    }\n\n    public static AuthClient getInstance() {\n        if (instance \u003d\u003d null) {\n            synchronized (AuthClient.class) {\n                if (instance \u003d\u003d null) {\n                    instance \u003d new AuthClient();\n                }\n            }\n        }\n        return instance;\n    }\n\n    /**\n     * --- MÉTODO ANTIGUO (MODIFICADO) ---\n     * Realiza la petición al token endpoint POR DEFECTO (realm \u0027taller\u0027).\n     * Ahora delega la llamada al nuevo método sobrecargado.\n     */\n    public Response requestTokenResponse(String username, String password) {\n        log.debug(\"Solicitando token (por defecto) para user\u003d{}\", username);\n        // Llama al método de trabajo principal usando la URL por defecto\n        return requestTokenResponse(username, password, this.defaultTokenUrl);\n    }\n\n    /**\n     * --- MÉTODO NUEVO (SOBRECARGADO) ---\n     * Esta es la corrección clave.\n     * Realiza la petición al token endpoint en una URL ESPECÍFICA.\n     * Lo usaremos para llamar al realm \u0027master\u0027 cuando pidamos el token de admin.\n     */\n    public Response requestTokenResponse(String username, String password, String specificTokenUrl) {\n        log.debug(\"Solicitando token para user\u003d{} en URL\u003d{}\", username, specificTokenUrl);\n\n        Response response \u003d given()\n                // Corregido: RestAssured recomienda ContentType.URLENC\n                .contentType(ContentType.URLENC) \n                .formParam(\"grant_type\", \"password\")\n                .formParam(\"client_id\", clientId)\n                .formParam(\"client_secret\", clientSecret)\n                .formParam(\"username\", username)\n                .formParam(\"password\", password)\n                .when()\n                .post(specificTokenUrl); // \u003c-- Usa la URL específica\n\n        log.debug(\"Token endpoint → status\u003d{} body\u003d{}\",\n                response.statusCode(), safeBody(response));\n\n        return response;\n    }\n\n\n    /**\n     * Obtiene el access_token y lanza excepción si la respuesta no es exitosa.\n     * (Este método no cambia, seguirá usando el realm por defecto \u0027taller\u0027)\n     */\n    public String getAccessToken(String username, String password) {\n        Response r \u003d requestTokenResponse(username, password); // Llama al método por defecto\n        if (r.statusCode() !\u003d 200) {\n            log.error(\"Error obteniendo token. Status: {}, Body: {}\", r.statusCode(), safeBody(r));\n            throw new RuntimeException(\"No se pudo obtener el token de acceso. Status: \" + r.statusCode());\n        }\n        String token \u003d r.jsonPath().getString(\"access_token\");\n        log.debug(\"Token obtenido correctamente para {} ({} caracteres)\", username, token !\u003d null ? token.length() : 0);\n        return token;\n    }\n\n    /**\n     * Llama al endpoint userinfo con el token proporcionado.\n     * (Este método no cambia)\n     */\n    public Response getUserInfo(String accessToken) {\n        log.debug(\"Llamando al endpoint userinfo\");\n        Response response \u003d given()\n                .header(\"Authorization\", \"Bearer \" + accessToken)\n                .when()\n                .get(userInfoUrl);\n\n        log.debug(\"Userinfo → status\u003d{} body\u003d{}\", response.statusCode(), safeBody(response));\n        return response;\n    }\n\n    private String safeBody(Response response) {\n        try {\n            return response.getBody() !\u003d null ? response.getBody().asString() : \"(sin cuerpo)\";\n        } catch (Exception e) {\n            return \"(error leyendo body)\";\n        }\n    }\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 116
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/TokenClient.java",
      "timestamp": 1763071235401,
      "startOffset": 2464,
      "endOffset": 4841,
      "codeContent": "                \n                tokenCache.put(cacheKey, new TokenInfo(newToken, expiresIn));\n                log.debug(\"Nuevo token guardado en caché para {} (expira en {}s)\", username, expiresIn);\n                return newToken;\n            } else {\n                log.warn(\"No se obtuvo token (status {}). Body: {}\", response.statusCode(), response.getBody().asString());\n                return null;\n            }\n        } catch (Exception e) {\n            log.error(\"Error al solicitar token para {}: {}\", username, e.getMessage());\n            throw new RuntimeException(\"Error al comunicarse con Keycloak: \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Obtiene el token del usuario administrador configurado en TestConfig.\n     * --- MÉTODO CORREGIDO ---\n     * Llama al realm \u0027master\u0027 con el client_id \u0027admin-cli\u0027 y sin secret.\n     */\n    public String getAdminToken() {\n        String cacheKey \u003d \"admin_master_token\"; // Clave de caché específica\n        TokenInfo tokenInfo \u003d tokenCache.get(cacheKey);\n\n        if (tokenInfo !\u003d null \u0026\u0026 !tokenInfo.isExpired()) {\n            log.debug(\"Reutilizando token de admin en caché\");\n            return tokenInfo.getAccessToken();\n        }\n\n        log.debug(\"Solicitando nuevo token de admin al realm \u0027master\u0027\");\n        String newToken;\n        int expiresIn \u003d 240; // fallback\n\n        try {\n            // Obtenemos las URLs y credenciales CORRECTAS\n            String masterTokenUrl \u003d config.getMasterTokenUrl(); // http://.../master/...\n            String adminClientId \u003d config.getAdminClientId();   // \"admin-cli\"\n\n            // Llamamos al método de AuthClient que lo soporta\n            Response response \u003d authClient.requestTokenResponse(\n                    config.getAdminUsername(),    // \"admin\"\n                    config.getAdminPassword(),    // \"admin123\"\n                    masterTokenUrl,               // URL del realm master\n                    adminClientId,                // \"admin-cli\"\n                    null                          // Sin client secret\n            );\n\n            if (response.statusCode() \u003d\u003d 200) {\n                newToken \u003d response.jsonPath().getString(\"access_token\");\n                Integer exp \u003d response.jsonPath().getInt(\"expires_in\");\n\n                if (exp !\u003d null \u0026\u0026 exp \u003e 0) {\n                    expiresIn \u003d exp;\n                }\n                ",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 54
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/ApiGatewayApplication.java",
      "timestamp": 1763076989977,
      "startOffset": 156,
      "endOffset": 404,
      "codeContent": "// Descomenta esta línea si usas Eureka o Consul. Si no, no es necesaria.\n// import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n\n@SpringBootApplication\n// @EnableDiscoveryClient // Opcional, dependiendo de tu service discovery",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 5
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/TokenClient.java",
      "timestamp": 1763079275989,
      "startOffset": 307,
      "endOffset": 6048,
      "codeContent": "@Slf4j\n@Getter\npublic class TokenClient {\n\n    private static TokenClient instance;\n\n    private final TestConfig config;\n    private final AuthClient authClient;\n    private final ConcurrentMap\u003cString, TokenInfo\u003e tokenCache;\n\n    private TokenClient() {\n        this.config \u003d TestConfig.getInstance();\n        this.authClient \u003d AuthClient.getInstance();\n        this.tokenCache \u003d new ConcurrentHashMap\u003c\u003e();\n    }\n\n    public static TokenClient getInstance() {\n        if (instance \u003d\u003d null) {\n            synchronized (TokenClient.class) {\n                if (instance \u003d\u003d null) {\n                    instance \u003d new TokenClient();\n                }\n            }\n        }\n        return instance;\n    }\n\n    // Metodo para obtener el token de cualquier usuario\n    public String getTokenForUser(String username, String password) {\n        return getToken(username, password);\n        // Reusa la lógica interna\n    }\n\n    /**\n     * Obtiene un token de acceso para un usuario (del realm \u0027taller\u0027),\n     * usando la caché si aún no expiró.\n     */\n    public String getToken(String username, String password) {\n        String cacheKey \u003d username;\n        TokenInfo tokenInfo \u003d tokenCache.get(cacheKey);\n\n        if (tokenInfo !\u003d null \u0026\u0026 !tokenInfo.isExpired()) {\n            log.debug(\"Reutilizando token en caché para usuario {}\", username);\n            return tokenInfo.getAccessToken();\n        }\n\n        log.debug(\"Solicitando nuevo token para usuario {}\", username);\n        String newToken;\n        int expiresIn \u003d 240; // fallback (4 min)\n\n        try {\n            // Llama al método por defecto de AuthClient (que usa realm \u0027taller\u0027)\n            Response response \u003d authClient.requestTokenResponse(username, password);\n            if (response.statusCode() \u003d\u003d 200) {\n                newToken \u003d response.jsonPath().getString(\"access_token\");\n                Integer exp \u003d response.jsonPath().getInt(\"expires_in\");\n\n                if (exp !\u003d null \u0026\u0026 exp \u003e 0) {\n                    expiresIn \u003d exp;\n                }\n\n                tokenCache.put(cacheKey, new TokenInfo(newToken, expiresIn));\n                log.debug(\"Nuevo token guardado en caché para {} (expira en {}s)\", username, expiresIn);\n                return newToken;\n            } else {\n                log.warn(\"No se obtuvo token (status {}). Body: {}\", response.statusCode(), response.getBody().asString());\n                return null;\n            }\n        } catch (Exception e) {\n            log.error(\"Error al solicitar token para {}: {}\", username, e.getMessage());\n            throw new RuntimeException(\"Error al comunicarse con Keycloak: \" + e.getMessage(), e);\n        }\n    }\n\n    /**\n     * Obtiene el token del usuario administrador configurado en TestConfig.\n     * --- MÉTODO CORREGIDO ---\n     * Llama al realm \u0027taller\u0027 (NO a \u0027master\u0027) con el client_id \u0027admin-cli\u0027.\n     */\n    public String getAdminToken() {\n        // Usamos una clave de caché diferente para el token de admin\n        String cacheKey \u003d config.getAdminUsername() + \"_admin_token\";\n        TokenInfo tokenInfo \u003d tokenCache.get(cacheKey);\n\n        if (tokenInfo !\u003d null \u0026\u0026 !tokenInfo.isExpired()) {\n            log.debug(\"Reutilizando token de admin en caché\");\n            return tokenInfo.getAccessToken();\n        }\n\n        log.debug(\"Solicitando nuevo token de admin al realm \u0027{}\u0027\", config.getKeycloakRealm());\n        String newToken;\n        int expiresIn \u003d 240; // fallback\n\n        try {\n            // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n            // ⬇️⬇️⬇️ INICIO DE LA CORRECCIÓN ⬇️⬇️⬇️\n            // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n            // Usamos la URL del realm \u0027taller\u0027, NO la del realm \u0027master\u0027\n            String tallerTokenUrl \u003d config.getKeycloakTokenUrl();\n            String adminClientId \u003d config.getAdminClientId();\n\n            // Llamamos al método de AuthClient que lo soporta\n            Response response \u003d authClient.requestTokenResponse(\n                    config.getAdminUsername(),    // \"admin\"\n                    config.getAdminPassword(),    // \"admin123\"\n                    tallerTokenUrl,               // URL del realm \u0027taller\u0027\n                    adminClientId,                // \"admin-cli\"\n                    null                          // Sin client secret\n            );\n            \n            // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n            // ⬆️⬆️⬆️ FIN DE LA CORRECCIÓN ⬆️⬆️⬆️\n            // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n            if (response.statusCode() \u003d\u003d 200) {\n                newToken \u003d response.jsonPath().getString(\"access_token\");\n                Integer exp \u003d response.jsonPath().getInt(\"expires_in\");\n\n                if (exp !\u003d null \u0026\u0026 exp \u003e 0) {\n                    expiresIn \u003d exp;\n                }\n\n                tokenCache.put(cacheKey, new TokenInfo(newToken, expiresIn));\n                log.debug(\"Nuevo token de ADMIN guardado en caché (expira en {}s)\", expiresIn);\n                return newToken;\n            } else {\n                log.error(\"¡FALLO CRÍTICO! No se pudo obtener el token de administrador.\");\n                log.error(\"El realm \u0027{}\u0027 de Keycloak en {} respondió con status {}. Body: {}\",\n                        config.getKeycloakRealm(), tallerTokenUrl, response.statusCode(), response.getBody().asString());\n                throw new RuntimeException(\"No se pudo obtener el token de administrador. Revisa la configuración.\");\n            }\n        } catch (Exception e) {\n            log.error(\"Error al solicitar token de admin: {}\", e.getMessage());\n            throw new RuntimeException(\"Error al comunicarse con Keycloak (admin",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 135
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/hooks/Hooks.java",
      "timestamp": 1763112024797,
      "startOffset": 705,
      "endOffset": 1228,
      "codeContent": "log.info(\"CONFIG RESUELTA:\");\nlog.info(\" - apiBaseUrl \u003d {}\", config.getApiBaseUrl());\nlog.info(\" - keycloakUrl \u003d {}\", config.getKeycloakUrl());\nlog.info(\" - keycloakTokenUrl \u003d {}\", config.getKeycloakTokenUrl());\n// Intenta obtener token admin sin lanzar (solo loguear)\ntry {\n    String t \u003d tokenClient.getAdminToken();\n    log.info(\" - admin token obtenido (longitud): {}\", t !\u003d null ? t.length() : \"null\");\n} catch (Exception e) {\n    log.warn(\" - No se pudo obtener token admin en beforeScenario: {}\", e.getMessage());\n}\n",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 12
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/hooks/Hooks.java",
      "timestamp": 1763112953547,
      "startOffset": 1370,
      "endOffset": 1402,
      "codeContent": "co.edu.uniquindio.tests.support.",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/hooks/Hooks.java",
      "timestamp": 1763112953561,
      "startOffset": 90,
      "endOffset": 145,
      "codeContent": "import co.edu.uniquindio.tests.support.ScenarioContext;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/controller/PerfilController.java",
      "timestamp": 1763139141779,
      "startOffset": 2997,
      "endOffset": 4011,
      "codeContent": "/**\n     * Endpoint para que el Gateway (u otro admin) obtenga un perfil por ID de usuario.\n     * En una app real, esto buscaría en un PerfilRepository.\n     */\n    @GetMapping(\"/por-usuario/{userId}\")\n    public ResponseEntity\u003cPerfilResponse\u003e obtenerPerfilPorUsuarioId(@PathVariable UUID userId) {\n        // --- STUB (Simulación) ---\n        // En una implementación real, aquí llamarías a:\n        // Perfil perfil \u003d perfilService.obtenerPorUsuarioId(userId);\n        // y construirías la respuesta.\n        \n        // Devolvemos datos dummy para que la agregación funcione:\n        PerfilRequest dummyRequest \u003d new PerfilRequest();\n        dummyRequest.setApodo(\"PerfilStub-\" + userId.toString().substring(0, 4));\n        dummyRequest.setBiografia(\"Biografía de prueba para el usuario \" + userId);\n        dummyRequest.setPaisResidencia(\"Colombia\");\n\n        PerfilResponse response \u003d new PerfilResponse(userId, dummyRequest);\n        return ResponseEntity.ok(response);\n        // --- Fin del STUB ---\n    }",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 21
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/ApiGatewayApplication.java",
      "timestamp": 1763139303498,
      "startOffset": 229,
      "endOffset": 1005,
      "codeContent": "import org.springframework.context.annotation.Bean; // Importar\nimport org.springframework.web.reactive.function.client.WebClient; // Importar\n\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class ApiGatewayApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ApiGatewayApplication.class, args);\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    // ⬇️⬇️⬇️ BEAN NUEVO REQUERIDO ⬇️⬇️⬇️\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    /**\n     * Provee un builder de WebClient para que los controladores\n     * y servicios puedan inyectarlo y hacer llamadas HTTP.\n     */\n    @Bean\n    public WebClient.Builder webClientBuilder() {\n        return WebClient.builder();\n    }",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 22
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/dto/UsuarioResponse.java",
      "timestamp": 1763139355826,
      "startOffset": 0,
      "endOffset": 73,
      "codeContent": "package co.edu.uniquindio.gateway.dto;\n\npublic class UsuarioResponse {\n}\n",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 5
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/dto/UsuarioResponse.java",
      "timestamp": 1763139363822,
      "startOffset": 40,
      "endOffset": 659,
      "codeContent": "import java.util.UUID;\n\n// DTO espejo de co.edu.uniquindio.tallerapi2.dto.UsuarioResponse\n// Necesario para que el Gateway pueda deserializar la respuesta del microservicio\npublic class UsuarioResponse {\n    private UUID id;\n    private String nombre;\n    private String email;\n\n    // Getters y Setters\n    public UUID getId() { return id; }\n    public void setId(UUID id) { this.id \u003d id; }\n    public String getNombre() { return nombre; }\n    public void setNombre(String nombre) { this.nombre \u003d nombre; }\n    public String getEmail() { return email; }\n    public void setEmail(String email) { this.email \u003d email; }\n}",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 17
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/dto/PerfilResponse.java",
      "timestamp": 1763139383675,
      "startOffset": 0,
      "endOffset": 72,
      "codeContent": "package co.edu.uniquindio.gateway.dto;\n\npublic class PerfilResponse {\n}\n",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 5
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/dto/PerfilResponse.java",
      "timestamp": 1763139389152,
      "startOffset": 40,
      "endOffset": 1853,
      "codeContent": "import java.util.Map;\nimport java.util.UUID;\n\n// DTO espejo de co.edu.uniquindio.tallerapi2.dto.PerfilResponse\npublic class PerfilResponse {\n    private UUID userId;\n    private String apodo;\n    private String biografia;\n    private String paginaPersonal;\n    private String direccion;\n    private String organizacion;\n    private String paisResidencia;\n    private Boolean informacionPublica;\n    private Map\u003cString, String\u003e redesSociales;\n\n    // Getters y Setters\n    public UUID getUserId() { return userId; }\n    public void setUserId(UUID userId) { this.userId \u003d userId; }\n    public String getApodo() { return apodo; }\n    public void setApodo(String apodo) { this.apodo \u003d apodo; }\n    public String getBiografia() { return biografia; }\n    public void setBiografia(String biografia) { this.biografia \u003d biografia; }\n    public String getPaginaPersonal() { return paginaPersonal; }\n    public void setPaginaPersonal(String paginaPersonal) { this.paginaPersonal \u003d paginaPersonal; }\n    public String getDireccion() { return direccion; }\n    public void setDireccion(String direccion) { this.direccion \u003d direccion; }\n    public String getOrganizacion() { return organizacion; }\n    public void setOrganizacion(String organizacion) { this.organizacion \u003d organizacion; }\n    public String getPaisResidencia() { return paisResidencia; }\n    public void setPaisResidencia(String paisResidencia) { this.paisResidencia \u003d paisResidencia; }\n    public Boolean getInformacionPublica() { return informacionPublica; }\n    public void setInformacionPublica(Boolean informacionPublica) { this.informacionPublica \u003d informacionPublica; }\n    public Map\u003cString, String\u003e getRedesSociales() { return redesSociales; }\n    public void setRedesSociales(Map\u003cString, String\u003e redesSociales) { this.redesSociales \u003d redesSociales; }\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 35
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/dto/UsuarioCompletoResponse.java",
      "timestamp": 1763139411973,
      "startOffset": 0,
      "endOffset": 81,
      "codeContent": "package co.edu.uniquindio.gateway.dto;\n\npublic class UsuarioCompletoResponse {\n}\n",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 5
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/dto/UsuarioCompletoResponse.java",
      "timestamp": 1763139417284,
      "startOffset": 40,
      "endOffset": 713,
      "codeContent": "// DTO de Agregación. Contiene la información de ambos servicios.\npublic class UsuarioCompletoResponse {\n    \n    private UsuarioResponse usuario;\n    private PerfilResponse perfil;\n\n    // Constructor para la agregación\n    public UsuarioCompletoResponse(UsuarioResponse usuario, PerfilResponse perfil) {\n        this.usuario \u003d usuario;\n        this.perfil \u003d perfil;\n    }\n\n    // Getters y Setters\n    public UsuarioResponse getUsuario() { return usuario; }\n    public void setUsuario(UsuarioResponse usuario) { this.usuario \u003d usuario; }\n    public PerfilResponse getPerfil() { return perfil; }\n    public void setPerfil(PerfilResponse perfil) { this.perfil \u003d perfil; }\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 18
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/controller/UsuarioAgregadoController.java",
      "timestamp": 1763139451879,
      "startOffset": 0,
      "endOffset": 90,
      "codeContent": "package co.edu.uniquindio.gateway.controller;\n\npublic class UsuarioAgregadoController {\n}\n",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 5
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/controller/UsuarioAgregadoController.java",
      "timestamp": 1763139456234,
      "startOffset": 47,
      "endOffset": 3239,
      "codeContent": "import co.edu.uniquindio.gateway.dto.PerfilResponse;\nimport co.edu.uniquindio.gateway.dto.UsuarioCompletoResponse;\nimport co.edu.uniquindio.gateway.dto.UsuarioResponse;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.reactive.function.client.WebClient;\nimport org.springframework.web.server.ResponseStatusException;\nimport reactor.core.publisher.Mono;\n\nimport java.util.UUID;\n\n@RestController\n@RequestMapping(\"/api/usuario-completo\")\npublic class UsuarioAgregadoController {\n\n    private final WebClient webClientTallerApi;\n\n    public UsuarioAgregadoController(WebClient.Builder webClientBuilder) {\n        // Creamos un WebClient que apunta al servicio \u0027taller-api-2\u0027\n        // \u0027taller-api-2\u0027 es el nombre del servicio en docker-compose.yml\n        this.webClientTallerApi \u003d webClientBuilder\n                .baseUrl(\"http://taller-api-2:8080\")\n                .build();\n    }\n\n    /**\n     * Implementa el requisito R6d:\n     * 1. Recibe una solicitud de \"datos completos\".\n     * 2. Divide la solicitud en dos llamadas (Fan-out).\n     * 3. Unifica las respuestas (Fan-in).\n     * 4. Devuelve una respuesta unificada.\n     */\n    @GetMapping(\"/{id}\")\n    public Mono\u003cResponseEntity\u003cUsuarioCompletoResponse\u003e\u003e getUsuarioCompleto(\n            @PathVariable String id,\n            @RequestHeader(HttpHeaders.AUTHORIZATION) String authorizationHeader) {\n\n        // 1. (Fan-out) Preparamos la llamada al endpoint de Usuarios\n        Mono\u003cUsuarioResponse\u003e usuarioMono \u003d webClientTallerApi.get()\n                .uri(\"/api/usuarios/\" + id)\n                .header(HttpHeaders.AUTHORIZATION, authorizationHeader) // Pasar el token\n                .retrieve()\n                // Si el usuario no existe, lanzamos un 404\n                .onStatus(\n                        status -\u003e status \u003d\u003d HttpStatus.NOT_FOUND,\n                        clientResponse -\u003e Mono.error(new ResponseStatusException(HttpStatus.NOT_FOUND, \"Usuario no encontrado\"))\n                )\n                .bodyToMono(UsuarioResponse.class);\n\n        // 2. (Fan-out) Preparamos la llamada al endpoint de Perfiles\n        Mono\u003cPerfilResponse\u003e perfilMono \u003d webClientTallerApi.get()\n                .uri(\"/api/perfiles/por-usuario/\" + id)\n                .header(HttpHeaders.AUTHORIZATION, authorizationHeader) // Pasar el token\n                .retrieve()\n                .bodyToMono(PerfilResponse.class)\n                // Si el perfil no existe (404) o da error, simplemente devolvemos un objeto vacío\n                .onErrorResume(e -\u003e Mono.just(new PerfilResponse())); \n\n        // 3. (Fan-in) Combinamos ambas respuestas cuando estén listas\n        return Mono.zip(usuarioMono, perfilMono)\n                .map(tupla -\u003e {\n                    // tupla.getT1() es la respuesta de usuarioMono\n                    // tupla.getT2() es la respuesta de perfilMono\n                    return new UsuarioCompletoResponse(tupla.getT1(), tupla.getT2());\n                })\n                .map(respuestaUnificada -\u003e ResponseEntity.ok(respuestaUnificada));\n    }\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 70
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/dto/events/UsuarioEliminadoEvent.java",
      "timestamp": 1763139554491,
      "startOffset": 0,
      "endOffset": 89,
      "codeContent": "package co.edu.uniquindio.tallerapi2.dto.events;\n\npublic class UsuarioEliminadoEvent {\n}\n",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 5
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/dto/events/UsuarioEliminadoEvent.java",
      "timestamp": 1763139559600,
      "startOffset": 50,
      "endOffset": 1308,
      "codeContent": "import com.fasterxml.jackson.annotation.JsonFormat;\nimport java.time.LocalDateTime;\nimport java.util.UUID;\n\n// DTO para el evento de usuario eliminado\npublic class UsuarioEliminadoEvent {\n\n    private UUID usuarioId;\n    private String email;\n    \n    @JsonFormat(shape \u003d JsonFormat.Shape.STRING, pattern \u003d \"yyyy-MM-dd\u0027T\u0027HH:mm:ss\")\n    private LocalDateTime timestamp;\n\n    private String eventType;\n\n    // Constructores\n    public UsuarioEliminadoEvent() {\n        this.timestamp \u003d LocalDateTime.now();\n        this.eventType \u003d \"USUARIO_ELIMINADO\";\n    }\n\n    public UsuarioEliminadoEvent(UUID usuarioId, String email) {\n        this();\n        this.usuarioId \u003d usuarioId;\n        this.email \u003d email;\n    }\n\n    // Getters y Setters\n    public UUID getUsuarioId() { return usuarioId; }\n    public void setUsuarioId(UUID usuarioId) { this.usuarioId \u003d usuarioId; }\n    public String getEmail() { return email; }\n    public void setEmail(String email) { this.email \u003d email; }\n    public LocalDateTime getTimestamp() { return timestamp; }\n    public void setTimestamp(LocalDateTime timestamp) { this.timestamp \u003d timestamp; }\n    public String getEventType() { return eventType; }\n    public void setEventType(String eventType) { this.eventType \u003d eventType; }\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 37
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139620719,
      "startOffset": 623,
      "endOffset": 672,
      "codeContent": "private Eliminados eliminados \u003d new Eliminados();",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139689838,
      "startOffset": 46,
      "endOffset": 4482,
      "codeContent": "// ... (imports) ...\n// ⬇️ Importar el nuevo DTO de evento ⬇️\nimport co.edu.uniquindio.tallerapi2.dto.events.UsuarioEliminadoEvent; \n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Configuration\npublic class RabbitMQConfig {\n\n    private final AppRabbitMQProperties properties;\n\n    public RabbitMQConfig(AppRabbitMQProperties properties) {\n        this.properties \u003d properties;\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d EXCHANGE \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    @Bean\n    public TopicExchange appExchange() {\n        return new TopicExchange(properties.getExchange());\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d QUEUES \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    @Bean\n    public Queue usuariosQueue() {\n        return new Queue(properties.getUsuarios().getQueue(), true);\n    }\n\n    @Bean\n    public Queue sesionesQueue() {\n        return new Queue(properties.getSesiones().getQueue(), true);\n    }\n\n    @Bean\n    public Queue passwordQueue() {\n        return new Queue(properties.getPassword().getQueue(), true);\n    }\n\n    // ⬇️ --- AÑADIR NUEVO BEAN DE COLA --- ⬇️\n    @Bean\n    public Queue usuariosEliminadosQueue() {\n        return new Queue(properties.getUsuarios().getEliminados().getQueue(), true);\n    }\n    // ⬆️ --- FIN DE LO AÑADIDO --- ⬆️\n\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d BINDINGS \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    @Bean\n    public Binding usuariosBinding(Queue usuariosQueue, TopicExchange appExchange) {\n        return BindingBuilder.bind(usuariosQueue)\n                .to(appExchange)\n                .with(properties.getUsuarios().getRoutingKey());\n    }\n\n    @Bean\n    public Binding sesionesBinding(Queue sesionesQueue, TopicExchange appExchange) {\n        return BindingBuilder.bind(sesionesQueue)\n                .to(appExchange)\n                .with(properties.getSesiones().getRoutingKey());\n    }\n\n    @Bean\n    public Binding passwordBinding(Queue passwordQueue, TopicExchange appExchange) {\n        return BindingBuilder.bind(passwordQueue)\n                .to(appExchange)\n                .with(properties.getPassword().getRoutingKey());\n    }\n\n    // ⬇️ --- AÑADIR NUEVO BEAN DE BINDING --- ⬇️\n    @Bean\n    public Binding usuariosEliminadosBinding(Queue usuariosEliminadosQueue, TopicExchange appExchange) {\n        return BindingBuilder.bind(usuariosEliminadosQueue)\n                .to(appExchange)\n                .with(properties.getUsuarios().getEliminados().getRoutingKey());\n    }\n    // ⬆️ --- FIN DE LO AÑADIDO --- ⬆️\n\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d MESSAGE CONVERTER \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    @Bean\n    public MessageConverter jsonMessageConverter() {\n        Jackson2JsonMessageConverter converter \u003d new Jackson2JsonMessageConverter();\n        DefaultClassMapper classMapper \u003d new DefaultClassMapper();\n        Map\u003cString, Class\u003c?\u003e\u003e idClassMapping \u003d new HashMap\u003c\u003e();\n        \n        idClassMapping.put(\"co.edu.uniquindio.tallerapi2.dto.events.UsuarioCreadoEvent\", UsuarioCreadoEvent.class);\n        idClassMapping.put(\"co.edu.uniquindio.tallerapi2.dto.events.SesionIniciadaEvent\", SesionIniciadaEvent.class);\n        idClassMapping.put(\"co.edu.uniquindio.tallerapi2.dto.events.PasswordResetSolicitadoEvent\", PasswordResetSolicitadoEvent.class);\n        idClassMapping.put(\"co.edu.uniquindio.tallerapi2.dto.events.PasswordActualizadoEvent\", PasswordActualizadoEvent.class);\n        \n        // ⬇️ --- AÑADIR MAPEADO DE CLASE DEL NUEVO EVENTO --- ⬇️\n        idClassMapping.put(\"co.edu.uniquindio.tallerapi2.dto.events.UsuarioEliminadoEvent\", UsuarioEliminadoEvent.class);\n        // ⬆️ --- FIN DE LO AÑADIDO --- ⬆️\n\n        classMapper.setIdClassMapping(idClassMapping);\n        converter.setClassMapper(classMapper);\n\n        return converter;\n    }\n\n    // ... (RabbitTemplate y ListenerFactory sin cambios) ...\n    @Bean\n    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory,\n                                         MessageConverter jsonMessageConverter) {\n        RabbitTemplate template \u003d new RabbitTemplate(connectionFactory);\n        template.setMessageConverter(jsonMessageConverter);\n        return template;\n    }\n\n    @Bean\n    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(ConnectionFactory connectionFactory,\n                                                                         MessageConverter jsonMessageConverter) {\n        SimpleRabbitListenerContainerFactory factory \u003d new SimpleRabbitListenerContainerFactory();\n        factory.setConnectionFactory(connectionFactory);\n        factory.setMessageConverter(jsonMessageConverter);\n        return factory",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 116
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139715668,
      "startOffset": 177,
      "endOffset": 237,
      "codeContent": "import org.springframework.context.annotation.Configuration;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139730389,
      "startOffset": 178,
      "endOffset": 229,
      "codeContent": "import org.springframework.context.annotation.Bean;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139751832,
      "startOffset": 275,
      "endOffset": 298,
      "codeContent": "import java.util.Queue;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139754825,
      "startOffset": 227,
      "endOffset": 288,
      "codeContent": "import org.springframework.context.annotation.Configuration;\n",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 2
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139756282,
      "startOffset": 743,
      "endOffset": 782,
      "codeContent": "org.springframework.context.annotation.",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139756910,
      "startOffset": 289,
      "endOffset": 328,
      "codeContent": "org.springframework.context.annotation.",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139770517,
      "startOffset": 46,
      "endOffset": 4482,
      "codeContent": "// ... (imports) ...\n// ⬇️ Importar el nuevo DTO de evento ⬇️\nimport co.edu.uniquindio.tallerapi2.dto.events.UsuarioEliminadoEvent; \n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Configuration\npublic class RabbitMQConfig {\n\n    private final AppRabbitMQProperties properties;\n\n    public RabbitMQConfig(AppRabbitMQProperties properties) {\n        this.properties \u003d properties;\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d EXCHANGE \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    @Bean\n    public TopicExchange appExchange() {\n        return new TopicExchange(properties.getExchange());\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d QUEUES \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    @Bean\n    public Queue usuariosQueue() {\n        return new Queue(properties.getUsuarios().getQueue(), true);\n    }\n\n    @Bean\n    public Queue sesionesQueue() {\n        return new Queue(properties.getSesiones().getQueue(), true);\n    }\n\n    @Bean\n    public Queue passwordQueue() {\n        return new Queue(properties.getPassword().getQueue(), true);\n    }\n\n    // ⬇️ --- AÑADIR NUEVO BEAN DE COLA --- ⬇️\n    @Bean\n    public Queue usuariosEliminadosQueue() {\n        return new Queue(properties.getUsuarios().getEliminados().getQueue(), true);\n    }\n    // ⬆️ --- FIN DE LO AÑADIDO --- ⬆️\n\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d BINDINGS \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    @Bean\n    public Binding usuariosBinding(Queue usuariosQueue, TopicExchange appExchange) {\n        return BindingBuilder.bind(usuariosQueue)\n                .to(appExchange)\n                .with(properties.getUsuarios().getRoutingKey());\n    }\n\n    @Bean\n    public Binding sesionesBinding(Queue sesionesQueue, TopicExchange appExchange) {\n        return BindingBuilder.bind(sesionesQueue)\n                .to(appExchange)\n                .with(properties.getSesiones().getRoutingKey());\n    }\n\n    @Bean\n    public Binding passwordBinding(Queue passwordQueue, TopicExchange appExchange) {\n        return BindingBuilder.bind(passwordQueue)\n                .to(appExchange)\n                .with(properties.getPassword().getRoutingKey());\n    }\n\n    // ⬇️ --- AÑADIR NUEVO BEAN DE BINDING --- ⬇️\n    @Bean\n    public Binding usuariosEliminadosBinding(Queue usuariosEliminadosQueue, TopicExchange appExchange) {\n        return BindingBuilder.bind(usuariosEliminadosQueue)\n                .to(appExchange)\n                .with(properties.getUsuarios().getEliminados().getRoutingKey());\n    }\n    // ⬆️ --- FIN DE LO AÑADIDO --- ⬆️\n\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d MESSAGE CONVERTER \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    @Bean\n    public MessageConverter jsonMessageConverter() {\n        Jackson2JsonMessageConverter converter \u003d new Jackson2JsonMessageConverter();\n        DefaultClassMapper classMapper \u003d new DefaultClassMapper();\n        Map\u003cString, Class\u003c?\u003e\u003e idClassMapping \u003d new HashMap\u003c\u003e();\n        \n        idClassMapping.put(\"co.edu.uniquindio.tallerapi2.dto.events.UsuarioCreadoEvent\", UsuarioCreadoEvent.class);\n        idClassMapping.put(\"co.edu.uniquindio.tallerapi2.dto.events.SesionIniciadaEvent\", SesionIniciadaEvent.class);\n        idClassMapping.put(\"co.edu.uniquindio.tallerapi2.dto.events.PasswordResetSolicitadoEvent\", PasswordResetSolicitadoEvent.class);\n        idClassMapping.put(\"co.edu.uniquindio.tallerapi2.dto.events.PasswordActualizadoEvent\", PasswordActualizadoEvent.class);\n        \n        // ⬇️ --- AÑADIR MAPEADO DE CLASE DEL NUEVO EVENTO --- ⬇️\n        idClassMapping.put(\"co.edu.uniquindio.tallerapi2.dto.events.UsuarioEliminadoEvent\", UsuarioEliminadoEvent.class);\n        // ⬆️ --- FIN DE LO AÑADIDO --- ⬆️\n\n        classMapper.setIdClassMapping(idClassMapping);\n        converter.setClassMapper(classMapper);\n\n        return converter;\n    }\n\n    // ... (RabbitTemplate y ListenerFactory sin cambios) ...\n    @Bean\n    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory,\n                                         MessageConverter jsonMessageConverter) {\n        RabbitTemplate template \u003d new RabbitTemplate(connectionFactory);\n        template.setMessageConverter(jsonMessageConverter);\n        return template;\n    }\n\n    @Bean\n    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(ConnectionFactory connectionFactory,\n                                                                         MessageConverter jsonMessageConverter) {\n        SimpleRabbitListenerContainerFactory factory \u003d new SimpleRabbitListenerContainerFactory();\n        factory.setConnectionFactory(connectionFactory);\n        factory.setMessageConverter(jsonMessageConverter);\n        return factory",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 116
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139788374,
      "startOffset": 122,
      "endOffset": 173,
      "codeContent": "import org.springframework.context.annotation.Bean;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139790332,
      "startOffset": 46,
      "endOffset": 97,
      "codeContent": "import org.springframework.amqp.core.TopicExchange;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139798605,
      "startOffset": 405,
      "endOffset": 428,
      "codeContent": "import java.util.Queue;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139803735,
      "startOffset": 671,
      "endOffset": 701,
      "codeContent": "org.springframework.amqp.core.",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139804256,
      "startOffset": 603,
      "endOffset": 642,
      "codeContent": "org.springframework.context.annotation.",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/service/EventPublisherService.java",
      "timestamp": 1763139854680,
      "startOffset": 803,
      "endOffset": 872,
      "codeContent": "import co.edu.uniquindio.tallerapi2.dto.events.UsuarioEliminadoEvent;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/service/EventPublisherService.java",
      "timestamp": 1763139883534,
      "startOffset": 1705,
      "endOffset": 2406,
      "codeContent": "/**\n     * Publica evento de usuario eliminado\n     */\n    public void publishUsuarioEliminado(UsuarioEliminadoEvent event) {\n        try {\n            log.info(\"Publicando evento de usuario eliminado: {}\", event);\n            rabbitTemplate.convertAndSend(\n                    properties.getExchange(),\n                    properties.getUsuarios().getEliminados().getRoutingKey(), // Usamos el nuevo routing key\n                    event\n            );\n            log.info(\"Evento de eliminación publicado exitosamente para usuario: {}\", event.getEmail());\n        } catch (Exception e) {\n            log.error(\"Error al publicar evento de usuario eliminado: {}\", e.getMessage(), e);\n        }\n    }",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 16
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/controller/UsuarioController.java",
      "timestamp": 1763139928337,
      "startOffset": 1899,
      "endOffset": 1968,
      "codeContent": "import co.edu.uniquindio.tallerapi2.dto.events.UsuarioEliminadoEvent;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/RabbitMQConfig.java",
      "timestamp": 1763140236096,
      "startOffset": 1070,
      "endOffset": 1139,
      "codeContent": "import co.edu.uniquindio.tallerapi2.dto.events.UsuarioEliminadoEvent;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763140493206,
      "startOffset": 514,
      "endOffset": 1269,
      "codeContent": "private Eliminados eliminados \u003d new Eliminados();\n        \n        // 2. Clase interna para la nueva configuración\n        public static class Eliminados {\n            private String queue;\n            private String routingKey;\n\n            public String getQueue() { return queue; }\n            public void setQueue(String queue) { this.queue \u003d queue; }\n            public String getRoutingKey() { return routingKey; }\n            public void setRoutingKey(String routingKey) { this.routingKey \u003d routingKey; }\n        }\n\n        // 3. Getters y Setters para el nuevo campo (¡ESTO ES LO QUE FALTA!)\n        public Eliminados getEliminados() { return eliminados; }\n        public void setEliminados(Eliminados eliminados) { this.eliminados \u003d eliminados; }",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 16
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763140532832,
      "startOffset": 291,
      "endOffset": 4087,
      "codeContent": "private String exchange;\n    [cite_start]private Usuarios usuarios \u003d new Usuarios(); [cite: 563]\n    [cite_start]private Sesiones sesiones \u003d new Sesiones(); [cite: 563]\n    [cite_start]private Password password \u003d new Password(); [cite: 563]\n\n    // ⬇️ ESTA ES LA CLASE MODIFICADA ⬇️\n    public static class Usuarios {\n        [cite_start]private String queue; [cite: 564]\n        [cite_start]private String routingKey; [cite: 564]\n        \n        // --- INICIO DE LA MODIFICACIÓN ---\n        // 1. Campo para la nueva configuración\n        private Eliminados eliminados \u003d new Eliminados();\n        \n        // 2. Clase interna para la nueva configuración\n        public static class Eliminados {\n            private String queue;\n            private String routingKey;\n\n            public String getQueue() { return queue; }\n            public void setQueue(String queue) { this.queue \u003d queue; }\n            public String getRoutingKey() { return routingKey; }\n            public void setRoutingKey(String routingKey) { this.routingKey \u003d routingKey; }\n        }\n\n        // 3. Getters y Setters para el nuevo campo (¡ESTO ES LO QUE FALTA!)\n        public Eliminados getEliminados() { return eliminados; }\n        public void setEliminados(Eliminados eliminados) { this.eliminados \u003d eliminados; }\n        // --- FIN DE LA MODIFICACIÓN ---\n\n        // (Getters y Setters originales de Usuarios)\n        [cite_start]public String getQueue() { [cite: 565]\n            return queue;\n        }\n        [cite_start]public void setQueue(String queue) { [cite: 566]\n            this.queue \u003d queue;\n        }\n        [cite_start]public String getRoutingKey() { [cite: 567]\n            return routingKey;\n        }\n        [cite_start]public void setRoutingKey(String routingKey) { [cite: 568]\n            this.routingKey \u003d routingKey;\n        }\n    }\n    // ⬆️ FIN DE LA CLASE MODIFICADA ⬆️\n\n\n    // (Clases Sesiones y Password sin cambios)\n    public static class Sesiones {\n        [cite_start]private String queue; [cite: 569]\n        [cite_start]private String routingKey; [cite: 570]\n        public String getQueue() { return queue; [cite_start]} [cite: 570-571]\n        public void setQueue(String queue) { this.queue \u003d queue; [cite_start]} [cite: 571-572]\n        public String getRoutingKey() { return routingKey; [cite_start]} [cite: 572-573]\n        public void setRoutingKey(String routingKey) { this.routingKey \u003d routingKey; [cite_start]} [cite: 573-574]\n    }\n\n    public static class Password {\n        [cite_start]private String queue; [cite: 574-575]\n        [cite_start]private String routingKey; [cite: 575]\n        public String getQueue() { return queue; [cite_start]} [cite: 575-576]\n        public void setQueue(String queue) { this.queue \u003d queue; [cite_start]} [cite: 576-577]\n        public String getRoutingKey() { return routingKey; [cite_start]} [cite: 577-578]\n        public void setRoutingKey(String routingKey) { this.routingKey \u003d routingKey; [cite_start]} [cite: 578-579]\n    }\n\n    // (Getters y setters principales sin cambios)\n    public String getExchange() { return exchange; [cite_start]} [cite: 579]\n    public void setExchange(String exchange) { this.exchange \u003d exchange; [cite_start]} [cite: 580-581]\n    public Usuarios getUsuarios() { return usuarios; [cite_start]} [cite: 581-582]\n    public void setUsuarios(Usuarios usuarios) { this.usuarios \u003d usuarios; [cite_start]} [cite: 582-583]\n    public Sesiones getSesiones() { return sesiones; [cite_start]} [cite: 583-584]\n    public void setSesiones(Sesiones sesiones) { this.sesiones \u003d sesiones; [cite_start]} [cite: 584-585]\n    public Password getPassword() { return password; [cite_start]} [cite: 585-586]\n    public void setPassword(Password password) { this.password \u003d password; [cite_start]} [cite: 586-587]",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 75
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/dto/events/UsuarioCreadoEvent.java",
      "timestamp": 1763144101977,
      "startOffset": 155,
      "endOffset": 206,
      "codeContent": "import com.fasterxml.jackson.annotation.JsonFormat;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/dto/events/SesionIniciadaEvent.java",
      "timestamp": 1763144135979,
      "startOffset": 336,
      "endOffset": 422,
      "codeContent": "@JsonFormat(shape \u003d JsonFormat.Shape.STRING, pattern \u003d \"yyyy-MM-dd\u0027T\u0027HH:mm:ss.SSSSSS\")",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/dto/events/SesionIniciadaEvent.java",
      "timestamp": 1763144139783,
      "startOffset": 50,
      "endOffset": 101,
      "codeContent": "import com.fasterxml.jackson.annotation.JsonFormat;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/dto/events/PasswordResetSolicitadoEvent.java",
      "timestamp": 1763144200191,
      "startOffset": 229,
      "endOffset": 357,
      "codeContent": "@JsonFormat(shape \u003d JsonFormat.Shape.STRING, pattern \u003d \"yyyy-MM-dd\u0027T\u0027HH:mm:ss.SSSSSS\")\n    private LocalDateTime fechaSolicitud;",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 2
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/dto/events/PasswordResetSolicitadoEvent.java",
      "timestamp": 1763144203847,
      "startOffset": 50,
      "endOffset": 101,
      "codeContent": "import com.fasterxml.jackson.annotation.JsonFormat;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/dto/events/PasswordResetSolicitadoEvent.java",
      "timestamp": 1763144205516,
      "startOffset": 103,
      "endOffset": 134,
      "codeContent": "import java.time.LocalDateTime;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/dto/events/PasswordActualizadoEvent.java",
      "timestamp": 1763144318930,
      "startOffset": 256,
      "endOffset": 278,
      "codeContent": "private String nombre;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/controller/PasswordController.java",
      "timestamp": 1763144568438,
      "startOffset": 1488,
      "endOffset": 21796,
      "codeContent": "\n    {\n        this.usuarioRepository \u003d usuarioRepository;\n        this.eventPublisher \u003d eventPublisher;\n        this.keycloakAdminService \u003d keycloakAdminService;\n        this.tokenService \u003d tokenService;\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    // 📧 API Endpoint: Solicitar reset\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    @PostMapping(\"/solicitar-reset\")\n    public ResponseEntity\u003c?\u003e solicitarReset(@RequestParam String email, HttpServletRequest req) {\n        Optional\u003cUsuario\u003e usuarioOpt \u003d usuarioRepository.findByEmail(email);\n        if (usuarioOpt.isEmpty()) {\n            return ResponseEntity.status(HttpStatus.NOT_FOUND)\n                    .body(new ApiError(404, \"Not Found\", \"Usuario no encontrado\", req.getRequestURI()));\n        }\n\n        try {\n            Usuario usuario \u003d usuarioOpt.get();\n            // Generar token seguro y guardarlo en BD\n            String token \u003d tokenService.generarTokenReset(usuario);\n            // ✅ Publicar SOLO evento de solicitud de reset (NO de actualización)\n            PasswordResetSolicitadoEvent event \u003d new PasswordResetSolicitadoEvent(\n                    usuario.getId(),\n                    email,\n                    usuario.getNombre(),\n                    token\n            );\n            eventPublisher.publishPasswordResetSolicitado(event);\n\n            return ResponseEntity.ok(\"Solicitud de reset enviada. Revisa tu correo electrónico.\");\n        } catch (RuntimeException e) {\n            return ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS)\n                    .body(new ApiError(429, \"Too Many Requests\", e.getMessage(), req.getRequestURI()));\n        }\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    // 🌐 HTML Endpoint: Mostrar formulario de reset\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    @GetMapping(value \u003d \"/reset\", produces \u003d MediaType.TEXT_HTML_VALUE)\n    public String mostrarFormularioReset(@RequestParam String email,\n                                         @RequestParam String token) {\n\n        // Validar si el token es válido\n        boolean valido \u003d tokenService.esTokenValido(token);\n        if (!valido) {\n            return generarHtmlError(\"Token Inválido\",\n                    \"El token de recuperación no es válido o ha expirado.\",\n                    \"Por favor, solicita un nuevo enlace de recuperación.\");\n        }\n\n        // Renderizar formulario de reset mejorado\n        return generarHtmlFormulario(email, token);\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    // 🔄 API/HTML Endpoint: Procesar reset (MÉTODO MODIFICADO)\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    @PostMapping(\"/reset\")\n    public Object resetPassword(@RequestParam String email,\n                                @RequestParam String nuevaClave,\n                                @RequestParam String token,\n                                @RequestHeader(value \u003d \"Accept\", defaultValue \u003d \"\") String acceptHeader,\n                                HttpServletRequest req) {\n\n        // Validar token en BD\n        Optional\u003cPasswordResetToken\u003e tokenOpt \u003d tokenService.validarToken(token);\n        if (tokenOpt.isEmpty()) {\n            return responseHtmlOrJson(\"Token Inválido\",\n                    \"El token de recuperación no es válido o ha expirado.\",\n                    \"Por favor, solicita un nuevo enlace de recuperación.\",\n                    req, acceptHeader, HttpStatus.BAD_REQUEST);\n        }\n\n        PasswordResetToken resetToken \u003d tokenOpt.get();\n        // Verificar que el email coincida con el del token\n        if (!resetToken.getUsuario().getEmail().equals(email)) {\n            return responseHtmlOrJson(\"Error de Validación\",\n                    \"El token no corresponde al email proporcionado.\",\n                    \"Verifica que estés usando el enlace correcto.\",\n                    req, acceptHeader, HttpStatus.BAD_REQUEST);\n        }\n\n        try {\n            // ✅ Actualizar contraseña en Keycloak\n            keycloakAdminService.actualizarPasswordUsuario(email, nuevaClave);\n\n            // Invalidar token (eliminarlo de BD para evitar reuso)\n            tokenService.invalidarToken(token);\n\n            // ⬇️ --- AQUÍ ESTÁ LA MODIFICACIÓN --- ⬇️\n            // Ahora pasamos el nombre del usuario al constructor del evento\n            PasswordActualizadoEvent event \u003d new PasswordActualizadoEvent(\n                    resetToken.getUsuario().getId(),\n                    email,\n                    resetToken.getUsuario().getNombre() // \u003c--- Campo añadido\n            );\n            // ⬆️ --- FIN DE LA MODIFICACIÓN --- ⬆️\n            \n            eventPublisher.publishPasswordActualizado(event);\n\n            return responseHtmlOrJson(\"¡Contraseña Actualizada!\",\n                    \"Tu contraseña ha sido cambiada exitosamente.\",\n                    \"Ya puedes iniciar sesión con tu nueva contraseña.\",\n                    req, acceptHeader, HttpStatus.OK);\n\n        } catch (Exception e) {\n            return responseHtmlOrJson(\"Error del Servidor\",\n                    \"No se pudo actualizar la contraseña.\",\n                    \"Error: \" + e.getMessage(),\n                    req, acceptHeader, HttpStatus.INTERNAL_SERVER_ERROR);\n        }\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    // 🔍 API Endpoint: Validar token\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    @GetMapping(\"/validar-token\")\n    public ResponseEntity\u003c?\u003e validarToken(@RequestParam String token, HttpServletRequest req) {\n        if (tokenService.esTokenValido(token)) {\n            return ResponseEntity.ok(\"Token válido\");\n        } else {\n            return ResponseEntity.status(HttpStatus.BAD_REQUEST)\n                    .body(new ApiError(400, \"Bad Request\", \"Token inválido o expirado\", req.getRequestURI()));\n        }\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    // 🛠️ Helper: Respuesta HTML o JSON\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    private Object responseHtmlOrJson(String titulo, String mensaje, String detalle,\n                                      HttpServletRequest req, String acceptHeader, HttpStatus status) {\n        if (acceptHeader.contains(\"text/html\")) {\n            if (status.is2xxSuccessful()) {\n                return generarHtmlExito(titulo, mensaje, detalle);\n            } else {\n                return generarHtmlError(titulo, mensaje, detalle);\n            }\n        }\n        return ResponseEntity.status(status)\n                .body(new ApiError(status.value(), status.getReasonPhrase(), mensaje, req.getRequestURI()));\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    // 🎨 Métodos auxiliares para generar HTML\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n    private String generarHtmlFormulario(String email, String token) {\n        return \"\"\"\n        \u003c!DOCTYPE html\u003e\n        \u003chtml lang\u003d\u0027es\u0027\u003e\n        \u003chead\u003e\n            \u003cmeta charset\u003d\u0027UTF-8\u0027\u003e\n            \u003cmeta name\u003d\u0027viewport\u0027 content\u003d\u0027width\u003ddevice-width, initial-scale\u003d1.0\u0027\u003e\n            \u003ctitle\u003eRestablecer Contraseña\u003c/title\u003e\n            \u003cstyle\u003e\n                * { box-sizing: border-box; }\n                body { \n                    font-family: \u0027Segoe UI\u0027, Tahoma, Geneva, Verdana, sans-serif; \n                    background: linear-gradient(135deg, #667eea 0%%, #764ba2 100%%);\n                    margin: 0; padding: 20px; min-height: 100vh; \n                    display: flex; align-items: center; justify-content: center;\n                }\n                .container { \n                    background: white; padding: 40px; border-radius: 12px;\n                    box-shadow: 0 8px 32px rgba(0,0,0,0.1); max-width: 450px; width: 100%%;\n                }\n                h2 { \n                    color: #333;\n                    text-align: center; margin-bottom: 30px; \n                    font-size: 24px; font-weight: 600;\n                }\n                .info { \n                    background: #e3f2fd;\n                    padding: 15px; border-radius: 8px; \n                    margin-bottom: 25px; border-left: 4px solid #2196f3;\n                    font-size: 14px;\n                }\n                .form-group { margin-bottom: 20px; }\n                label { \n                    display: block;\n                    margin-bottom: 8px; font-weight: 600; \n                    color: #555; font-size: 14px;\n                }\n                input[type\u003d\u0027password\u0027] { \n                    width: 100%%;\n                    padding: 14px; border: 2px solid #e1e5e9; \n                    border-radius: 8px; font-size: 16px; transition: border-color 0.3s;\n                }\n                input[type\u003d\u0027password\u0027]:focus { \n                    outline: none;\n                    border-color: #2196f3; \n                    box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);\n                }\n                .password-requirements { \n                    font-size: 12px;\n                    color: #666; margin-top: 5px; \n                    display: flex; align-items: center; gap: 5px;\n                }\n                .error-msg { \n                    color: #f44336;\n                    font-size: 14px; margin-bottom: 15px; \n                    padding: 10px; background: #ffebee; border-radius: 6px; display: none;\n                }\n                button { \n                    width: 100%%;\n                    padding: 14px; background: linear-gradient(135deg, #2196f3, #21cbf3);\n                    color: white; border: none; border-radius: 8px; font-size: 16px; \n                    font-weight: 600; cursor: pointer;\n                    transition: transform 0.2s;\n                }\n                button:hover { transform: translateY(-2px); }\n                button:disabled { \n                    background: #ccc;\n                    cursor: not-allowed; transform: none; \n                }\n                .strength-meter { \n                    height: 4px;\n                    background: #e1e5e9; border-radius: 2px; \n                    margin-top: 8px; overflow: hidden;\n                }\n                .strength-fill { \n                    height: 100%%;\n                    transition: width 0.3s, background-color 0.3s; \n                    width: 0%%; background: #f44336;\n                }\n            \u003c/style\u003e\n        \u003c/head\u003e\n        \u003cbody\u003e\n            \u003cdiv class\u003d\u0027container\u0027\u003e\n                \u003ch2\u003e🔐 Restablecer Contraseña\u003c/h2\u003e\n                \u003cdiv class\u003d\u0027info\u0027\u003e\n                     \u003cstrong\u003e📧 Email:\u003c/strong\u003e %s\n                \u003c/div\u003e\n                \n                \u003cform method\u003d\u0027post\u0027 action\u003d\u0027/api/password/reset\u0027 onsubmit\u003d\u0027return validateForm(event)\u0027\u003e\n                    \u003cinput type\u003d\u0027hidden\u0027 name\u003d\u0027email\u0027 value\u003d\u0027%s\u0027/\u003e\n                    \u003cinput type\u003d\u0027hidden\u0027 name\u003d\u0027token\u0027 value\u003d\u0027%s\u0027/\u003e\n                    \n                    \u003cdiv class\u003d\u0027form-group\u0027\u003e\n                        \u003clabel for\u003d\u0027nuevaClave\u0027\u003eNueva Contraseña:\u003c/label\u003e\n                        \u003cinput type\u003d\u0027password\u0027 id\u003d\u0027nuevaClave\u0027 name\u003d\u0027nuevaClave\u0027 \n                               required minlength\u003d\u00278\u0027 oninput\u003d\u0027checkPasswordStrength()\u0027/\u003e\n                        \u003cdiv class\u003d\u0027strength-meter\u0027\u003e\n                            \u003cdiv class\u003d\u0027strength-fill\u0027 id\u003d\u0027strengthFill\u0027\u003e\u003c/div\u003e\n                        \u003c/div\u003e\n                        \u003cdiv class\u003d\u0027password-requirements\u0027\u003e\n                            \u003cspan\u003e🔒\u003c/span\u003e Mínimo 8 caracteres\n                        \u003c/div\u003e\n                    \u003c/div\u003e\n                    \n                    \u003cdiv class\u003d\u0027form-group\u0027\u003e\n                        \u003clabel for\u003d\u0027confirmClave\u0027\u003eConfirmar Contraseña:\u003c/label\u003e\n                        \u003cinput type\u003d\u0027password\u0027 id\u003d\u0027confirmClave\u0027 required minlength\u003d\u00278\u0027 \n                               oninput\u003d\u0027validatePasswords()\u0027/\u003e\n                    \u003c/div\u003e\n                    \n                    \u003cdiv id\u003d\u0027errorMsg\u0027 class\u003d\u0027error-msg\u0027\u003e\u003c/div\u003e\n                    \n                    \u003cbutton type\u003d\u0027submit\u0027 id\u003d\u0027submitBtn\u0027\u003e\n                        🔄 Cambiar Contraseña\n                    \u003c/button\u003e\n                 \u003c/form\u003e\n            \u003c/div\u003e\n            \n            \u003cscript\u003e\n                function checkPasswordStrength() {\n                    const password \u003d document.getElementById(\u0027nuevaClave\u0027).value;\n                    const fill \u003d document.getElementById(\u0027strengthFill\u0027);\n                    \n                    let strength \u003d 0;\n                    if (password.length \u003e\u003d 8) strength +\u003d 25;\n                    if (/[A-Z]/.test(password)) strength +\u003d 25;\n                    if (/[0-9]/.test(password)) strength +\u003d 25;\n                    if (/[^A-Za-z0-9]/.test(password)) strength +\u003d 25;\n                    \n                    fill.style.width \u003d strength + \u0027%%\u0027;\n                    if (strength \u003c 50) fill.style.background \u003d \u0027#f44336\u0027;\n                    else if (strength \u003c 75) fill.style.background \u003d \u0027#ff9800\u0027;\n                    else fill.style.background \u003d \u0027#4caf50\u0027;\n                    \n                    validatePasswords();\n                }\n                \n                function validatePasswords() {\n                    const pass1 \u003d document.getElementById(\u0027nuevaClave\u0027).value;\n                    const pass2 \u003d document.getElementById(\u0027confirmClave\u0027).value;\n                    const errorMsg \u003d document.getElementById(\u0027errorMsg\u0027);\n                    const submitBtn \u003d document.getElementById(\u0027submitBtn\u0027);\n                    \n                    if (pass2 \u0026\u0026 pass1 !\u003d\u003d pass2) {\n                        errorMsg.textContent \u003d \u0027❌ Las contraseñas no coinciden\u0027;\n                        errorMsg.style.display \u003d \u0027block\u0027;\n                        submitBtn.disabled \u003d true;\n                    } else {\n                        errorMsg.style.display \u003d \u0027none\u0027;\n                        submitBtn.disabled \u003d false;\n                    }\n                }\n                \n                function validateForm(event) {\n                    const pass1 \u003d document.getElementById(\u0027nuevaClave\u0027).value;\n                    const pass2 \u003d document.getElementById(\u0027confirmClave\u0027).value;\n                    \n                    if (pass1 !\u003d\u003d pass2) {\n                        event.preventDefault();\n                        document.getElementById(\u0027errorMsg\u0027).textContent \u003d \u0027❌ Las contraseñas no coinciden\u0027;\n                        document.getElementById(\u0027errorMsg\u0027).style.display \u003d \u0027block\u0027;\n                        return false;\n                    }\n                    \n                    if (pass1.length \u003c 8) {\n                        event.preventDefault();\n                        document.getElementById(\u0027errorMsg\u0027).textContent \u003d \u0027❌ La contraseña debe tener al menos 8 caracteres\u0027;\n                        document.getElementById(\u0027errorMsg\u0027).style.display \u003d \u0027block\u0027;\n                        return false;\n                    }\n                    \n                    return true;\n                }\n            \u003c/script\u003e\n        \u003c/body\u003e\n        \u003c/html\u003e\n        \"\"\".formatted(email, email, token);\n    }\n\n    private String generarHtmlExito(String titulo, String mensaje, String detalle) {\n        return \"\"\"\n        \u003c!DOCTYPE html\u003e\n        \u003chtml lang\u003d\u0027es\u0027\u003e\n        \u003chead\u003e\n             \u003cmeta charset\u003d\u0027UTF-8\u0027\u003e\n            \u003cmeta name\u003d\u0027viewport\u0027 content\u003d\u0027width\u003ddevice-width, initial-scale\u003d1.0\u0027\u003e\n            \u003ctitle\u003e%s\u003c/title\u003e\n            \u003cstyle\u003e\n                * { box-sizing: border-box; }\n                body { \n                    font-family: \u0027Segoe UI\u0027, Tahoma, Geneva, Verdana, sans-serif;\n                    background: linear-gradient(135deg, #4caf50 0%%, #45a049 100%%);\n                    margin: 0; padding: 20px; min-height: 100vh; \n                    display: flex; align-items: center; justify-content: center;\n                }\n                .container { \n                    background: white;\n                    padding: 40px; border-radius: 12px; \n                    box-shadow: 0 8px 32px rgba(0,0,0,0.1); max-width: 450px; \n                    width: 100%%; text-align: center;\n                }\n                .success-icon { \n                    font-size: 64px;\n                    margin-bottom: 20px; \n                    animation: bounce 1s ease-in-out;\n                }\n                @keyframes bounce {\n                    0%%, 20%%, 50%%, 80%%, 100%% { transform: translateY(0); }\n                    40%% { transform: translateY(-10px); }\n                    60%% { transform: translateY(-5px); }\n                }\n                h2 { \n                    color: #4caf50;\n                    margin-bottom: 20px; font-size: 24px; \n                    font-weight: 600;\n                }\n                p { \n                    color: #666;\n                    line-height: 1.6; margin-bottom: 20px; \n                    font-size: 16px;\n                }\n                .detail { \n                    background: #e8f5e8;\n                    padding: 20px; border-radius: 8px; \n                    border-left: 4px solid #4caf50; font-size: 14px; color: #2e7d32;\n                }\n                .login-link {\n                    margin-top: 20px;\n                    padding: 12px 24px; background: #2196f3;\n                    color: white; text-decoration: none; border-radius: 6px;\n                    display: inline-block; font-weight: 600; transition: background 0.3s;\n                }\n                .login-link:hover { background: #1976d2; }\n            \u003c/style\u003e\n        \u003c/head\u003e\n        \u003cbody\u003e\n            \u003cdiv class\u003d\u0027container\u0027\u003e\n                \u003cdiv class\u003d\u0027success-icon\u0027\u003e✅\u003c/div\u003e\n                \u003ch2\u003e%s\u003c/h2\u003e\n                \u003cp\u003e%s\u003c/p\u003e\n                 \u003cdiv class\u003d\u0027detail\u0027\u003e%s\u003c/div\u003e\n                \u003ca href\u003d\u0027/api/sesiones\u0027 class\u003d\u0027login-link\u0027\u003e🔑 Ir a Iniciar Sesión\u003c/a\u003e\n            \u003c/div\u003e\n        \u003c/body\u003e\n        \u003c/html\u003e\n        \"\"\".formatted(titulo, titulo, mensaje, detalle);\n    }\n\n    private String generarHtmlError(String titulo, String mensaje, String detalle) {\n        return \"\"\"\n         \u003c!DOCTYPE html\u003e\n        \u003chtml lang\u003d\u0027es\u0027\u003e\n        \u003chead\u003e\n            \u003cmeta charset\u003d\u0027UTF-8\u0027\u003e\n            \u003cmeta name\u003d\u0027viewport\u0027 content\u003d\u0027width\u003ddevice-width, initial-scale\u003d1.0\u0027\u003e\n            \u003ctitle\u003e%s\u003c/title\u003e\n            \u003cstyle\u003e\n                * { box-sizing: border-box; }\n                body { \n                    font-family: \u0027Segoe UI\u0027, Tahoma, Geneva, Verdana, sans-serif;\n                    background: linear-gradient(135deg, #f44336 0%%, #d32f2f 100%%);\n                    margin: 0; padding: 20px; min-height: 100vh; \n                    display: flex; align-items: center; justify-content: center;\n                }\n                .container { \n                    background: white;\n                    padding: 40px; border-radius: 12px; \n                    box-shadow: 0 8px 32px rgba(0,0,0,0.1); max-width: 450px; \n                    width: 100%%; text-align: center;\n                }\n                .error-icon { \n                    font-size: 64px;\n                    margin-bottom: 20px; color: #f44336;\n                    animation: shake 0.5s ease-in-out;\n                }\n                @keyframes shake {\n                    0%%, 100%% { transform: translateX(0); }\n                    25%% { transform: translateX(-5px); }\n                    75%% { transform: translateX(5px); }\n                }\n                h2 { \n                    color: #f44336;\n                    margin-bottom: 20px; font-size: 24px; \n                    font-weight: 600;\n                }\n                p { \n                    color: #666;\n                    line-height: 1.6; margin-bottom: 20px; \n                    font-size: 16px;\n                }\n                .detail { \n                    background: #ffebee;\n                    padding: 20px; border-radius: 8px; \n                    border-left: 4px solid #f44336; font-size: 14px; color: #c62828;\n                }\n                .retry-link {\n                    margin-top: 20px;\n                    padding: 12px 24px; background: #2196f3;\n                    color: white; text-decoration: none; border-radius: 6px;\n                    display: inline-block; font-weight: 600; transition: background 0.3s;\n                }\n                .retry-link:hover { background: #1976d2; }\n            \u003c/style\u003e\n        \u003c/head\u003e\n        \u003cbody\u003e\n            \u003cdiv class\u003d\u0027container\u0027\u003e\n                \u003cdiv class\u003d\u0027error-icon\u0027\u003e❌\u003c/div\u003e\n                \u003ch2\u003e%s\u003c/h2\u003e\n                \u003cp\u003e%s\u003c/p\u003e\n ",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 460
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/controller/SesionController.java",
      "timestamp": 1763157408893,
      "startOffset": 328,
      "endOffset": 394,
      "codeContent": "import co.edu.uniquindio.tallerapi2.service.EventPublisherService;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "/SesionController.java",
      "timestamp": 1763157411918,
      "startOffset": 1571,
      "endOffset": 1591,
      "codeContent": "IntellijIdeaRulezzz ",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/controller/SesionController.java",
      "timestamp": 1763157464201,
      "startOffset": 1605,
      "endOffset": 4651,
      "codeContent": "@Operation(summary \u003d \"Iniciar sesión\",\n            description \u003d \"Autentica un usuario con email y contraseña\")\n    @ApiResponses(value \u003d {\n            @ApiResponse(responseCode \u003d \"200\", description \u003d \"Sesión iniciada exitosamente\"),\n            @ApiResponse(responseCode \u003d \"401\", description \u003d \"Credenciales inválidas\",\n                    content \u003d @Content(schema \u003d @Schema(implementation \u003d ApiError.class))),\n \n           @ApiResponse(responseCode \u003d \"404\", description \u003d \"Usuario no encontrado\",\n                    content \u003d @Content(schema \u003d @Schema(implementation \u003d ApiError.class))),\n            @ApiResponse(responseCode \u003d \"400\", description \u003d \"Datos de entrada inválidos\",\n                    content \u003d @Content(schema \u003d @Schema(implementation \u003d ApiError.class)))\n    })\n    @PostMapping\n  \n  public ResponseEntity\u003c?\u003e iniciarSesion(\n            @Valid @RequestBody SesionRequest request,\n            HttpServletRequest httpRequest) {\n\n        try {\n            Optional\u003cUsuario\u003e usuarioOpt \u003d usuarioRepository.findByEmail(request.getEmail());\nif (usuarioOpt.isEmpty()) {\n                return ResponseEntity.status(HttpStatus.NOT_FOUND)\n                        .body(new ApiError(404, \"Not Found\", \"Usuario no encontrado\", httpRequest.getRequestURI()));\n}\n\n            Usuario usuario \u003d usuarioOpt.get();\nif (!usuario.getPassword().equals(request.getPassword())) {\n                return ResponseEntity.status(HttpStatus.UNAUTHORIZED)\n                        .body(new ApiError(401, \"Unauthorized\", \"Credenciales inválidas\", httpRequest.getRequestURI()));\n}\n\n            // --- INICIO DE CAMBIOS ---\n            // 🔥 PUBLICAR EVENTO DE SESIÓN INICIADA\n            try {\n                String ipAddress \u003d httpRequest.getRemoteAddr();\n                String userAgent \u003d httpRequest.getHeader(\"User-Agent\");\n\n                SesionIniciadaEvent event \u003d new SesionIniciadaEvent(\n                    usuario.getId().toString(), // Convertir UUID a String\n                    usuario.getEmail(),\n                    usuario.getNombre(),\n                    ipAddress,\n                    userAgent,\n                    \"Dispositivo Desconocido\" // Puedes mejorar esto si es necesario\n                );\n                eventPublisher.publishSesionIniciada(event);\n            } catch (Exception e) {\n                // No fallar el login si el evento falla, solo registrarlo\n                System.err.println(\"❌ Error publicando evento SESSION_STARTED: \" + e.getMessage());\n            }\n            // --- FIN DE CAMBIOS ---\n\nSesionResponse response \u003d new SesionResponse(\n                    \"Sesión iniciada exitosamente\",\n                    usuario.getId(),\n                    usuario.getEmail(),\n                    usuario.getNombre()\n            );\nreturn ResponseEntity.ok(response);\n\n        } catch (Exception e) {\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                    .body(new ApiError(500, \"Internal Server Error\", \"Error interno del servidor\", httpRequest.getRequestURI()));\n}\n    }",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 65
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/controller/SesionController.java",
      "timestamp": 1763157467674,
      "startOffset": 1605,
      "endOffset": 4651,
      "codeContent": "@Operation(summary \u003d \"Iniciar sesión\",\n            description \u003d \"Autentica un usuario con email y contraseña\")\n    @ApiResponses(value \u003d {\n            @ApiResponse(responseCode \u003d \"200\", description \u003d \"Sesión iniciada exitosamente\"),\n            @ApiResponse(responseCode \u003d \"401\", description \u003d \"Credenciales inválidas\",\n                    content \u003d @Content(schema \u003d @Schema(implementation \u003d ApiError.class))),\n \n           @ApiResponse(responseCode \u003d \"404\", description \u003d \"Usuario no encontrado\",\n                    content \u003d @Content(schema \u003d @Schema(implementation \u003d ApiError.class))),\n            @ApiResponse(responseCode \u003d \"400\", description \u003d \"Datos de entrada inválidos\",\n                    content \u003d @Content(schema \u003d @Schema(implementation \u003d ApiError.class)))\n    })\n    @PostMapping\n  \n  public ResponseEntity\u003c?\u003e iniciarSesion(\n            @Valid @RequestBody SesionRequest request,\n            HttpServletRequest httpRequest) {\n\n        try {\n            Optional\u003cUsuario\u003e usuarioOpt \u003d usuarioRepository.findByEmail(request.getEmail());\nif (usuarioOpt.isEmpty()) {\n                return ResponseEntity.status(HttpStatus.NOT_FOUND)\n                        .body(new ApiError(404, \"Not Found\", \"Usuario no encontrado\", httpRequest.getRequestURI()));\n}\n\n            Usuario usuario \u003d usuarioOpt.get();\nif (!usuario.getPassword().equals(request.getPassword())) {\n                return ResponseEntity.status(HttpStatus.UNAUTHORIZED)\n                        .body(new ApiError(401, \"Unauthorized\", \"Credenciales inválidas\", httpRequest.getRequestURI()));\n}\n\n            // --- INICIO DE CAMBIOS ---\n            // 🔥 PUBLICAR EVENTO DE SESIÓN INICIADA\n            try {\n                String ipAddress \u003d httpRequest.getRemoteAddr();\n                String userAgent \u003d httpRequest.getHeader(\"User-Agent\");\n\n                SesionIniciadaEvent event \u003d new SesionIniciadaEvent(\n                    usuario.getId().toString(), // Convertir UUID a String\n                    usuario.getEmail(),\n                    usuario.getNombre(),\n                    ipAddress,\n                    userAgent,\n                    \"Dispositivo Desconocido\" // Puedes mejorar esto si es necesario\n                );\n                eventPublisher.publishSesionIniciada(event);\n            } catch (Exception e) {\n                // No fallar el login si el evento falla, solo registrarlo\n                System.err.println(\"❌ Error publicando evento SESSION_STARTED: \" + e.getMessage());\n            }\n            // --- FIN DE CAMBIOS ---\n\nSesionResponse response \u003d new SesionResponse(\n                    \"Sesión iniciada exitosamente\",\n                    usuario.getId(),\n                    usuario.getEmail(),\n                    usuario.getNombre()\n            );\nreturn ResponseEntity.ok(response);\n\n        } catch (Exception e) {\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                    .body(new ApiError(500, \"Internal Server Error\", \"Error interno del servidor\", httpRequest.getRequestURI()));\n}\n    }",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 65
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/controller/SesionController.java",
      "timestamp": 1763157471597,
      "startOffset": 211,
      "endOffset": 278,
      "codeContent": "import co.edu.uniquindio.tallerapi2.dto.events.SesionIniciadaEvent;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "/SesionController.java",
      "timestamp": 1763157487618,
      "startOffset": 210,
      "endOffset": 278,
      "codeContent": "\nimport co.edu.uniquindio.tallerapi2.dto.events.SesionIniciadaEvent;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 2
    },
    {
      "filePath": "/SesionIniciadaEvent.java",
      "timestamp": 1763157555254,
      "startOffset": 316,
      "endOffset": 336,
      "codeContent": "IntellijIdeaRulezzz ",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/dto/events/SesionIniciadaEvent.java",
      "timestamp": 1763157560244,
      "startOffset": 221,
      "endOffset": 243,
      "codeContent": "import java.util.UUID;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "/SesionIniciadaEvent.java",
      "timestamp": 1763157569058,
      "startOffset": 221,
      "endOffset": 244,
      "codeContent": "\nimport java.util.UUID;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 2
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/controller/UsuarioController.java",
      "timestamp": 1763157689642,
      "startOffset": 4533,
      "endOffset": 4553,
      "codeContent": "                    ",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/controller/UsuarioController.java",
      "timestamp": 1763157689648,
      "startOffset": 6684,
      "endOffset": 6713,
      "codeContent": "\n                            ",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 2
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/controller/UsuarioController.java",
      "timestamp": 1763157689644,
      "startOffset": 5441,
      "endOffset": 5461,
      "codeContent": "                    ",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/controller/UsuarioController.java",
      "timestamp": 1763157689661,
      "startOffset": 10541,
      "endOffset": 10561,
      "codeContent": "                    ",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/controller/UsuarioController.java",
      "timestamp": 1763157689664,
      "startOffset": 11685,
      "endOffset": 11714,
      "codeContent": "\n                            ",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 2
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/controller/UsuarioController.java",
      "timestamp": 1763157689669,
      "startOffset": 14327,
      "endOffset": 14356,
      "codeContent": "\n                            ",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 2
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/controller/UsuarioController.java",
      "timestamp": 1763157717711,
      "startOffset": 1899,
      "endOffset": 25590,
      "codeContent": "import co.edu.uniquindio.tallerapi2.dto.events.UsuarioEliminadoEvent;\n\nimport java.time.LocalDateTime;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.UUID;\nimport java.util.HashMap;\n\nimport lombok.extern.slf4j.Slf4j; // Importar si no está\n\nimport java.time.LocalDateTime; // Importar si no está\n\n@RestController\n@RequestMapping(\"/api/usuarios\")\n@Tag(name \u003d \"Usuarios\", description \u003d \"Gestión de usuarios del sistema\")\n@Slf4j // 👈 Agregar la anotación\npublic class UsuarioController {\n\n    private final UsuarioRepository usuarioRepository;\n    private final PasswordResetTokenRepository tokenRepository;\n    private final EventPublisherService eventPublisher;\n    private final KeycloakAdminService keycloakAdminService;\n    private final PasswordEncoder passwordEncoder;\n\n    public UsuarioController(UsuarioRepository usuarioRepository,\n                             PasswordResetTokenRepository tokenRepository,\n                             EventPublisherService eventPublisher,\n                             KeycloakAdminService keycloakAdminService,\n                             PasswordEncoder passwordEncoder) {\n        this.usuarioRepository \u003d usuarioRepository;\n        this.tokenRepository \u003d tokenRepository;\n        this.eventPublisher \u003d eventPublisher;\n        this.keycloakAdminService \u003d keycloakAdminService;\n        this.passwordEncoder \u003d passwordEncoder;\n    }\n\n    @Operation(summary \u003d \"Listar usuarios con paginación\",\n            description \u003d \"Obtiene una lista paginada de todos los usuarios registrados\")\n    @ApiResponses(value \u003d {\n            @ApiResponse(responseCode \u003d \"200\", description \u003d \"Lista de usuarios obtenida exitosamente\"),\n            @ApiResponse(responseCode \u003d \"400\", description \u003d \"Parámetros de paginación inválidos\",\n                    content \u003d @Content(schema \u003d @Schema(implementation \u003d ApiError.class)))\n    })\n    @GetMapping\n    public ResponseEntity\u003cPage\u003cUsuarioResponse\u003e\u003e listarUsuarios(\n            @Parameter(description \u003d \"Número de página (inicia en 0)\", example \u003d \"0\")\n            @RequestParam(defaultValue \u003d \"0\") int page,\n\n            @Parameter(description \u003d \"Tamaño de página\", example \u003d \"10\")\n            @RequestParam(defaultValue \u003d \"10\") int size,\n\n            @Parameter(description \u003d \"Campo por el cual ordenar\", example \u003d \"nombre\")\n            @RequestParam(defaultValue \u003d \"nombre\") String sortBy,\n\n            @Parameter(description \u003d \"Dirección del ordenamiento\", example \u003d \"asc\")\n            @RequestParam(defaultValue \u003d \"asc\") String sortDir) {\n\n        try {\n            Sort sort \u003d sortDir.equalsIgnoreCase(\"desc\") ?\n                    Sort.by(sortBy).descending() :\n                    Sort.by(sortBy).ascending();\n\n            Pageable pageable \u003d PageRequest.of(page, size, sort);\n            Page\u003cUsuario\u003e usuariosPage \u003d usuarioRepository.findAll(pageable);\n\n            Page\u003cUsuarioResponse\u003e responsePage \u003d usuariosPage.map(UsuarioResponse::fromEntity);\n\n            return ResponseEntity.ok(responsePage);\n\n        } catch (Exception e) {\n            return ResponseEntity.badRequest().build();\n        }\n    }\n\n    @Operation(summary \u003d \"Buscar usuarios por nombre\",\n            description \u003d \"Busca y retorna usuarios cuyo nombre coincida parcialmente\")\n    @ApiResponses(value \u003d {\n            @ApiResponse(responseCode \u003d \"200\", description \u003d \"Usuarios encontrados\"),\n            @ApiResponse(responseCode \u003d \"204\", description \u003d \"No se encontraron usuarios con ese nombre\")\n    })\n    @GetMapping(\"/search\")\n    public ResponseEntity\u003cList\u003cUsuarioResponse\u003e\u003e buscarUsuariosPorNombre(\n            @Parameter(description \u003d \"Término de búsqueda para el nombre\", required \u003d true)\n            @RequestParam String name) {\n\n        List\u003cUsuario\u003e usuarios \u003d usuarioRepository.findAll().stream()\n                .filter(u -\u003e u.getNombre().toLowerCase().contains(name.toLowerCase()))\n                .toList();\n\n        if (usuarios.isEmpty()) {\n            // Devolvemos 200 con lista vacía, como espera el test (aunque 204 sería más semántico)\n            return ResponseEntity.ok(List.of());\n        }\n        return ResponseEntity.ok(usuarios.stream().map(UsuarioResponse::fromEntity).toList());\n    }\n\n\n    @Operation(summary \u003d \"Cambiar contraseña (usuario autenticado)\",\n            description \u003d \"Permite al usuario autenticado cambiar su propia contraseña\")\n    @ApiResponses(value \u003d {\n            @ApiResponse(responseCode \u003d \"200\", description \u003d \"Contraseña actualizada exitosamente\"),\n            @ApiResponse(responseCode \u003d \"400\", description \u003d \"Contraseña actual incorrecta\",\n                    content \u003d @Content(schema \u003d @Schema(implementation \u003d ApiError.class))),\n            @ApiResponse(responseCode \u003d \"404\", description \u003d \"Usuario no encontrado en DB (desincronizado de token)\",\n                    content \u003d @Content(schema \u003d @Schema(implementation \u003d ApiError.class)))\n    })\n    @PutMapping(\"/password\")\n    public ResponseEntity\u003cMap\u003cString, String\u003e\u003e cambiarPassword(\n            @Valid @RequestBody PasswordChangeRequest request,\n            JwtAuthenticationToken token) {\n\n        String email \u003d token.getToken().getClaimAsString(\"email\");\n        Usuario usuario \u003d usuarioRepository.findByEmail(email)\n                .orElseThrow(() -\u003e new ResponseStatusException(HttpStatus.NOT_FOUND, \"Usuario no encontrado en DB\"));\n\n        String dbPassword \u003d usuario.getPassword();\n        boolean passwordMatch \u003d false;\n\n        try {\n            if (dbPassword !\u003d null) {\n                passwordMatch \u003d passwordEncoder.matches(request.getCurrentPassword(), dbPassword);\n            } else {\n                // Si el password en DB es null (típico en Keycloak),\n                // lo tratamos como que NO CONCUERDA para forzar el 400.\n                passwordMatch \u003d false;\n            }\n\n        } catch (IllegalArgumentException e) {\n            // Esto captura el error si dbPassword no es un hash BCrypt válido o es null\n            // y se pasó directamente a matches sin la comprobación anterior.\n            log.warn(\"Password en DB no es un hash válido o es null para {}: {}\", email, e.getMessage());\n            passwordMatch \u003d false;\n        }\n\n        if (!passwordMatch) {\n            // En lugar de lanzar una excepción, devolvemos un 400 con un mensaje claro\n            return ResponseEntity.status(HttpStatus.BAD_REQUEST)\n                    .body(Map.of(\"mensaje\", \"La contraseña actual es incorrecta\"));\n        }\n\n        // 2. Actualizar en Keycloak y DB\n        try {\n            keycloakAdminService.actualizarPasswordUsuario(email, request.getNewPassword());\n\n            // Si Keycloak fue exitoso, actualizamos localmente\n            usuario.setPassword(passwordEncoder.encode(request.getNewPassword()));\n            usuarioRepository.save(usuario);\n\n            return ResponseEntity.ok(Map.of(\"mensaje\", \"Contraseña actualizada exitosamente\"));\n        } catch (Exception e) {\n            // Capturar cualquier fallo de Keycloak u otro error y devolver un 500\n            log.error(\"Error al actualizar la contraseña en Keycloak/DB para el usuario {}: {}\", email, e.getMessage(), e);\n\n            // Devolver un 500 con el formato de error que espera el cliente/test\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                    .body((Map)Map.of(\n                            \"status\", 500,\n                            \"error\", \"Internal Server Error\",\n                            \"message\", \"Error interno del servidor\",\n                            \"timestamp\", LocalDateTime.now().toString(),\n                            \"path\", \"/api/usuarios/password\"\n                    ));\n        }\n    }\n\n    @Operation(summary \u003d \"Obtener usuario por ID\",\n            description \u003d \"Busca y retorna un usuario específico por su ID\")\n    @ApiResponses(value \u003d {\n            @ApiResponse(responseCode \u003d \"200\", description \u003d \"Usuario encontrado\"),\n            @ApiResponse(responseCode \u003d \"404\", description \u003d \"Usuario no encontrado\",\n                    content \u003d @Content(schema \u003d @Schema(implementation \u003d ApiError.class))),\n            @ApiResponse(responseCode \u003d \"400\", description \u003d \"ID inválido\",\n                    content \u003d @Content(schema \u003d @Schema(implementation \u003d ApiError.class)))\n    })\n    @GetMapping(\"/{id}\")\n    public ResponseEntity\u003c?\u003e obtenerUsuario(\n            @Parameter(description \u003d \"ID único del usuario\", required \u003d true)\n            @PathVariable UUID id,\n            HttpServletRequest request) {\n\n        try {\n            Optional\u003cUsuario\u003e usuarioOpt \u003d usuarioRepository.findById(id);\n\n            if (usuarioOpt.isPresent()) {\n                return ResponseEntity.ok(UsuarioResponse.fromEntity(usuarioOpt.get()));\n            }\n\n            return ResponseEntity.status(HttpStatus.NOT_FOUND)\n                    .body(new ApiError(404, \"Not Found\", \"Usuario no encontrado\", request.getRequestURI()));\n\n        } catch (IllegalArgumentException e) {\n            return ResponseEntity.badRequest()\n                    .body(new ApiError(400, \"Bad Request\", \"ID de usuario inválido\", request.getRequestURI()));\n        }\n    }\n\n    @Operation(summary \u003d \"Crear nuevo usuario\",\n            description \u003d \"Registra un nuevo usuario en el sistema\")\n    @ApiResponses(value \u003d {\n            @ApiResponse(responseCode \u003d \"201\", description \u003d \"Usuario creado exitosamente\"),\n            @ApiResponse(responseCode \u003d \"400\", description \u003d \"Datos de entrada inválidos\",\n                    content \u003d @Content(schema \u003d @Schema(implementation \u003d ApiError.class))),\n            @ApiResponse(responseCode \u003d \"409\", description \u003d \"El email ya está registrado\",\n                    content \u003d @Content(schema \u003d @Schema(implementation \u003d ApiError.class)))\n    })\n    @PostMapping\n    public ResponseEntity\u003c?\u003e crearUsuario(\n            @Valid @RequestBody UsuarioRequest request,\n            HttpServletRequest httpRequest) {\n\n        try {\n            if (usuarioRepository.findByEmail(request.getEmail()).isPresent()) {\n                return ResponseEntity.status(HttpStatus.CONFLICT)\n                        .body(new ApiError(409, \"Conflict\", \"Ya existe un usuario con ese email\", httpRequest.getRequestURI()));\n            }\n\n            Usuario usuario \u003d new Usuario();\n            usuario.setNombre(request.getNombre());\n            usuario.setEmail(request.getEmail());\n            usuario.setPassword(passwordEncoder.encode(request.getPassword()));\n\n            Usuario usuarioGuardado \u003d usuarioRepository.save(usuario);\n\n            keycloakAdminService.crearUsuarioEnKeycloak(\n                    usuarioGuardado.getNombre(),\n                    usuarioGuardado.getEmail(),\n                    request.getPassword()\n            );\n\n            UsuarioCreadoEvent evento \u003d UsuarioCreadoEvent.fromUsuario(usuarioGuardado);\n            eventPublisher.publishUsuarioCreado(evento);\n\n            Map\u003cString, Object\u003e responseBody \u003d new HashMap\u003c\u003e();\n            responseBody.put(\"mensaje\", \"Usuario creado exitosamente\");\n            responseBody.put(\"id\", usuarioGuardado.getId().toString());\n            responseBody.put(\"usuario\", UsuarioResponse.fromEntity(usuarioGuardado));\n            responseBody.put(\"eventoPublicado\", true);\n\n            return ResponseEntity.status(HttpStatus.CREATED).body(responseBody);\n\n        } catch (DataIntegrityViolationException e) {\n            throw new UsuarioDuplicadoException(\"Ya existe un usuario con ese email\", e);\n        } catch (Exception e) {\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                    .body(new ApiError(500, \"Internal Server Error\", \"Error interno del servidor: \" + e.getMessage(), httpRequest.getRequestURI()));\n        }\n    }\n\n    @Operation(summary \u003d \"Actualizar usuario\",\n            description \u003d \"Actualiza los datos de un usuario existente\")\n    @ApiResponses(value \u003d {\n            @ApiResponse(responseCode \u003d \"200\", description \u003d \"Usuario actualizado exitosamente\"),\n            @ApiResponse(responseCode \u003d \"404\", description \u003d \"Usuario no encontrado\",\n                    content \u003d @Content(schema \u003d @Schema(implementation \u003d ApiError.class))),\n            @ApiResponse(responseCode \u003d \"400\", description \u003d \"Datos de entrada inválidos\",\n                    content \u003d @Content(schema \u003d @Schema(implementation \u003d ApiError.class))),\n            @ApiResponse(responseCode \u003d \"409\", description \u003d \"El email ya está en uso por otro usuario\",\n                    content \u003d @Content(schema \u003d @Schema(implementation \u003d ApiError.class)))\n    })\n    @PutMapping(\"/{id}\")\n    public ResponseEntity\u003c?\u003e actualizarUsuario(\n            @Parameter(description \u003d \"ID único del usuario\", required \u003d true)\n            @PathVariable UUID id,\n            @Valid @RequestBody UsuarioUpdateRequest request,\n            HttpServletRequest httpRequest) {\n\n        try {\n            Usuario usuario \u003d usuarioRepository.findById(id)\n                    .orElseThrow(() -\u003e new ResponseStatusException(HttpStatus.NOT_FOUND, \"Usuario no encontrado\"));\n\n            if (request.getEmail() !\u003d null \u0026\u0026 !request.getEmail().isBlank()) {\n                Optional\u003cUsuario\u003e usuarioConEmail \u003d usuarioRepository.findByEmail(request.getEmail());\n                if (usuarioConEmail.isPresent() \u0026\u0026 !usuarioConEmail.get().getId().equals(id)) {\n                    return ResponseEntity.status(HttpStatus.CONFLICT)\n                            .body(new ApiError(409, \"Conflict\", \"Ya existe otro usuario con ese email\", httpRequest.getRequestURI()));\n                }\n                usuario.setEmail(request.getEmail());\n            }\n\n            if (request.getNombre() !\u003d null \u0026\u0026 !request.getNombre().isBlank()) {\n                usuario.setNombre(request.getNombre());\n            }\n\n            Usuario usuarioActualizado \u003d usuarioRepository.save(usuario);\n\n            return ResponseEntity.ok(UsuarioResponse.fromEntity(usuarioActualizado));\n\n        } catch (IllegalArgumentException e) {\n            return ResponseEntity.badRequest()\n                    .body(new ApiError(400, \"Bad Request\", \"ID de usuario inválido\", httpRequest.getRequestURI()));\n        } catch (Exception e) {\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                    .body(new ApiError(500, \"Internal Server Error\", \"Error interno del servidor\", httpRequest.getRequestURI()));\n        }\n    }\n\n    @Operation(summary \u003d \"Eliminar usuario\",\n            description \u003d \"Elimina un usuario del sistema y publica un evento\") // Descripción actualizada\n    @ApiResponses(value \u003d {\n            @ApiResponse(responseCode \u003d \"200\", description \u003d \"Usuario eliminado exitosamente\"),\n            @ApiResponse(responseCode \u003d \"404\", description \u003d \"Usuario no encontrado\",\n                    content \u003d @Content(schema \u003d @Schema(implementation \u003d ApiError.class))),\n            @ApiResponse(responseCode \u003d \"400\", description \u003d \"ID inválido\",\n                    content \u003d @Content(schema \u003d @Schema(implementation \u003d ApiError.class)))\n    })\n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity\u003c?\u003e eliminarUsuario(\n            @Parameter(description \u003d \"ID único del usuario\", required \u003d true)\n            @PathVariable UUID id,\n            HttpServletRequest request) {\n\n        try {\n            Optional\u003cUsuario\u003e usuarioOpt \u003d usuarioRepository.findById(id);\n            if (usuarioOpt.isEmpty()) {\n                return ResponseEntity.status(HttpStatus.NOT_FOUND)\n                        .body(new ApiError(404, \"Not Found\", \"Usuario no encontrado\", request.getRequestURI()));\n            }\n\n            // --- INICIO DE LA MODIFICACIÓN ---\n            Usuario usuario \u003d usuarioOpt.get();\n            String email \u003d usuario.getEmail(); // Capturamos los datos ANTES de borrar\n\n            // 1. Eliminar de la base de datos\n            usuarioRepository.deleteById(id);\n\n            // 2. Publicar el evento de eliminación\n            UsuarioEliminadoEvent evento \u003d new UsuarioEliminadoEvent(id, email);\n            eventPublisher.publishUsuarioEliminado(evento);\n\n            log.info(\"Usuario {} eliminado y evento publicado.\", id);\n            // --- FIN DE LA MODIFICACIÓN ---\n\n            return ResponseEntity.ok(Map.of(\"mensaje\", \"Usuario eliminado exitosamente\"));\n\n        } catch (IllegalArgumentException e) {\n            return ResponseEntity.badRequest()\n                    .body(new ApiError(400, \"Bad Request\", \"ID de usuario inválido\", request.getRequestURI()));\n        } catch (Exception e) {\n            // Captura errores si, por ejemplo, el evento no se puede publicar (aunque no debería detener la eliminación)\n            log.error(\"Error en el proceso de eliminación para el ID {}: {}\", id, e.getMessage(), e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                    .body(new ApiError(500, \"Internal Server Error\", \"Error interno del servidor\", request.getRequestURI()));\n        }\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d ENDPOINTS DE RECUPERACIÓN DE CONTRASEÑA \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n    @Operation(summary \u003d \"Solicitar recuperación de contraseña\",\n            description \u003d \"Genera un token de recuperación y lo envía por email\")\n    @ApiResponses(value \u003d {\n            @ApiResponse(responseCode \u003d \"200\", description \u003d \"Token de recuperación generado exitosamente\"),\n            @ApiResponse(responseCode \u003d \"404\", description \u003d \"Usuario no encontrado\",\n                    content \u003d @Content(schema \u003d @Schema(implementation \u003d ApiError.class))),\n            @ApiResponse(responseCode \u003d \"400\", description \u003d \"Datos de entrada inválidos\",\n                    content \u003d @Content(schema \u003d @Schema(implementation \u003d ApiError.class)))\n    })\n    @PostMapping(\"/recovery\")\n    public ResponseEntity\u003c?\u003e solicitarRecuperacion(\n            @Valid @RequestBody PasswordRecoveryRequest request,\n            HttpServletRequest httpRequest) {\n\n        try {\n            Optional\u003cUsuario\u003e usuarioOpt \u003d usuarioRepository.findByEmail(request.getEmail());\n\n            if (usuarioOpt.isEmpty()) {\n                return ResponseEntity.status(HttpStatus.NOT_FOUND)\n                        .body(new ApiError(404, \"Not Found\", \"No existe un usuario registrado con ese correo\", httpRequest.getRequestURI()));\n            }\n\n            Usuario usuario \u003d usuarioOpt.get();\n\n            tokenRepository.deleteByUsuario(usuario);\n\n            String token \u003d UUID.randomUUID().toString();\n            PasswordResetToken resetToken \u003d new PasswordResetToken();\n            resetToken.setToken(token);\n            resetToken.setUsuario(usuario);\n            resetToken.setExpiration(LocalDateTime.now().plusMinutes(15));\n\n            tokenRepository.save(resetToken);\n\n            PasswordResetSolicitadoEvent evento \u003d new PasswordResetSolicitadoEvent(\n                    usuario.getId(), usuario.getEmail(), usuario.getNombre(), token\n            );\n            eventPublisher.publishPasswordResetSolicitado(evento);\n\n            return ResponseEntity.ok(Map.of(\n                    \"mensaje\", \"Token de recuperación generado exitosamente\",\n                    \"token\", token,\n                    \"expiration\", \"15 minutos\",\n                    \"resetUrl\", \"POST /api/usuarios/reset-password\"\n            ));\n\n        } catch (Exception e) {\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                    .body(new ApiError(500, \"Internal Server Error\", \"Error interno del servidor\", httpRequest.getRequestURI()));\n        }\n    }\n\n    @Operation(summary \u003d \"Restablecer contraseña\",\n            description \u003d \"Cambia la contraseña usando un token de recuperación válido\")\n    @ApiResponses(value \u003d {\n            @ApiResponse(responseCode \u003d \"200\", description \u003d \"Contraseña actualizada exitosamente\"),\n            @ApiResponse(responseCode \u003d \"400\", description \u003d \"Token inválido o expirado\",\n                    content \u003d @Content(schema \u003d @Schema(implementation \u003d ApiError.class))),\n            @ApiResponse(responseCode \u003d \"404\", description \u003d \"Token no encontrado\",\n                    content \u003d @Content(schema \u003d @Schema(implementation \u003d ApiError.class)))\n    })\n    @PostMapping(\"/reset-password\")\n    public ResponseEntity\u003c?\u003e restablecerPassword(\n            @Valid @RequestBody PasswordResetRequest request,\n            HttpServletRequest httpRequest) {\n\n        try {\n            Optional\u003cPasswordResetToken\u003e tokenOpt \u003d tokenRepository.findByToken(request.getToken());\n\n            if (tokenOpt.isEmpty()) {\n                return ResponseEntity.status(HttpStatus.NOT_FOUND)\n                        .body(new ApiError(404, \"Not Found\", \"Token no válido\", httpRequest.getRequestURI()));\n            }\n\n            PasswordResetToken resetToken \u003d tokenOpt.get();\n\n            if (resetToken.isExpired()) {\n                tokenRepository.delete(resetToken);\n                return ResponseEntity.badRequest()\n                        .body(new ApiError(400, \"Bad Request\", \"El token ha expirado. Solicita una nueva recuperación\", httpRequest.getRequestURI()));\n            }\n\n            Usuario usuario \u003d resetToken.getUsuario();\n            usuario.setPassword(passwordEncoder.encode(request.getNewPassword()));\n            usuarioRepository.save(usuario);\n\n            tokenRepository.delete(resetToken);\n\n            PasswordActualizadoEvent evento \u003d new PasswordActualizadoEvent(\n                    usuario.getId(), usuario.getEmail()\n            );\n            eventPublisher.publishPasswordActualizado(evento);\n\n            return ResponseEntity.ok(Map.of(\n                    \"mensaje\", \"Contraseña actualizada exitosamente\",\n                    \"usuarioId\", usuario.getId().toString(),\n                    \"email\", usuario.getEmail()\n            ));\n\n        } catch (Exception e) {\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                    .body(new ApiError(500, \"Internal Server Error\", \"Error interno del servidor\", httpRequest.getRequestURI()));\n        }\n    }\n\n    @Operation(summary \u003d \"Verificar token de recuperación\",\n            description \u003d \"Valida si un token de recuperación es válido y no ha expirado\")\n    @ApiResponses(value \u003d {\n            @ApiResponse(responseCode \u003d \"200\", description \u003d \"Token válido\"),\n            @ApiResponse(responseCode \u003d \"400\", description \u003d \"Token inválido o expirado\",\n                    content \u003d @Content(schema \u003d @Schema(implementation \u003d ApiError.class)))\n    })\n    @GetMapping(\"/verify-token/{token}\")\n    public ResponseEntity\u003c?\u003e verificarToken(\n            @Parameter(description \u003d \"Token de recuperación\", required \u003d true)\n            @PathVariable String token,\n            HttpServletRequest request) {\n\n        try {\n            Optional\u003cPasswordResetToken\u003e tokenOpt \u003d tokenRepository.findByToken(token);\n\n            if (tokenOpt.isEmpty()) {\n                return ResponseEntity.badRequest()\n                        .body(new ApiError(400, \"Bad Request\", \"Token no válido\", request.getRequestURI()));\n            }\n\n            PasswordResetToken resetToken \u003d tokenOpt.get();\n\n            if (resetToken.isExpired()) {\n                return ResponseEntity.badRequest()\n                        .body(new ApiError(400, \"Bad Request\", \"Token expirado\", request.getRequestURI()));\n            }\n\n            return ResponseEntity.ok(Map.of(\n                    \"mensaje\", \"Token válido\",\n                    \"email\", resetToken.getUsuario().getEmail(),\n                    \"expiration\", resetToken.getExpiration().toString()\n            ));\n\n        } catch (Exception e) {\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                    .body(new ApiError(500, \"Internal Server Error\", \"Error interno del servidor\", request.getRequestURI()));\n        ",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 491
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/controller/SesionController.java",
      "timestamp": 1763157809581,
      "startOffset": 3591,
      "endOffset": 3631,
      "codeContent": "co.edu.uniquindio.tallerapi2.dto.events.",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/profile-service-go/repository.java",
      "timestamp": 1763159006403,
      "startOffset": 0,
      "endOffset": 51,
      "codeContent": "package PACKAGE_NAME;\n\npublic class repository {\n}\n",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 5
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/profile-service-go/api/handlers.go",
      "timestamp": 1763159337973,
      "startOffset": 0,
      "endOffset": 2785,
      "codeContent": "package api\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\n\t\"co.edu.uniquindio.gateway/model\"\n\t\"co.edu.uniquindio.gateway/repository\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/google/uuid\"\n\t\"gorm.io/datatypes\"\n)\n\n// HealthCheck (Requerido por [cite: 1774])\nfunc HealthCheck(c *gin.Context) {\n\tc.JSON(http.StatusOK, gin.H{\n\t\t\"status\":  \"UP\",\n\t\t\"service\": \"profile-service-go\",\n\t})\n}\n\n// GetPerfilPorUsuarioID (Usado por el ApiGateway para la agregación [cite: 1768-1769])\nfunc GetPerfilPorUsuarioID(c *gin.Context) {\n\tuserIDStr :\u003d c.Param(\"userId\")\n\tuserID, err :\u003d uuid.Parse(userIDStr)\n\tif err !\u003d nil {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"ID de usuario inválido\"})\n\t\treturn\n\t}\n\n\tvar perfil model.Perfil\n\t// Buscar el perfil por el ID de usuario\n\tresult :\u003d repository.DB.First(\u0026perfil, \"usuario_id \u003d ?\", userID)\n\n\tif result.Error !\u003d nil {\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": \"Perfil no encontrado\"})\n\t\treturn\n\t}\n\n\tc.JSON(http.StatusOK, perfil)\n}\n\n// GetMiPerfil (Usado por el usuario autenticado para ver su propio perfil)\nfunc GetMiPerfil(c *gin.Context) {\n\t// Extraemos el userID que el AuthMiddleware inyectó\n\tuserID :\u003d c.MustGet(\"userID\").(uuid.UUID)\n\n\tvar perfil model.Perfil\n\t// Buscar. Si no existe, creamos uno vacío en la BD.\n\tresult :\u003d repository.DB.FirstOrCreate(\u0026perfil, model.Perfil{UsuarioID: userID})\n\t\n\tif result.Error !\u003d nil {\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"No se pudo obtener o crear el perfil\"})\n\t\treturn\n\t}\n\n\tc.JSON(http.StatusOK, perfil)\n}\n\n// UpdateMiPerfil (Usado por el usuario autenticado para actualizar su perfil )\nfunc UpdateMiPerfil(c *gin.Context) {\n\tuserID :\u003d c.MustGet(\"userID\").(uuid.UUID)\n\n\tvar req model.UpdatePerfilRequest\n\tif err :\u003d c.ShouldBindJSON(\u0026req); err !\u003d nil {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\t// Convertir el map de redes sociales a JSONB\n\tredesJSON, err :\u003d json.Marshal(req.RedesSociales)\n\tif err !\u003d nil {\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Error procesando redes sociales\"})\n\t\treturn\n\t}\n\n\t// 1. Encontrar el perfil existente o crear uno nuevo si no existe\n\tvar perfil model.Perfil\n\trepository.DB.FirstOrCreate(\u0026perfil, model.Perfil{UsuarioID: userID})\n\n\t// 2. Actualizar los campos\n\tperfil.Apodo \u003d req.Apodo\n\tperfil.Biografia \u003d req.Biografia\n\tperfil.PaginaPersonal \u003d req.PaginaPersonal\n\tperfil.Direccion \u003d req.Direccion\n\tperfil.Organizacion \u003d req.Organizacion\n\tperfil.PaisResidencia \u003d req.PaisResidencia\n\tperfil.InformacionPublica \u003d req.InformacionPublica\n\tperfil.RedesSociales \u003d datatypes.JSON(redesJSON)\n\t\n\t// 3. Guardar en la BD\n\tresult :\u003d repository.DB.Save(\u0026perfil)\n\tif result.Error !\u003d nil {\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"No se pudo actualizar el perfil\"})\n\t\treturn\n\t}\n\n\tc.JSON(http.StatusOK, perfil)\n}",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 99
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/profile-service-go/main.go",
      "timestamp": 1763159361314,
      "startOffset": 23,
      "endOffset": 1141,
      "codeContent": "\t\"log\"\n\t\"os\"\n\n\t\"co.edu.uniquindio.gateway/api\"\n\t\"co.edu.uniquindio.gateway/repository\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\t// 1. Conectar a la Base de Datos\n\trepository.InitDB()\n\n\t// 2. Configurar servidor Gin\n\trouter :\u003d gin.Default()\n\t\n\t// Endpoint de Health (público) [cite: 1774]\n\trouter.GET(\"/health\", api.HealthCheck)\n\n\t// Agrupar rutas de la API\n\tapiRoutes :\u003d router.Group(\"/api\")\n\t{\n\t\t// Rutas para el API Gateway (Agregación)\n\t\t// Esta ruta NO usa el middleware porque el Gateway ya validó el token.\n\t\tapiRoutes.GET(\"/perfiles/por-usuario/:userId\", api.GetPerfilPorUsuarioID)\n\t\t\n\t\t// Rutas para el usuario final (requieren X-User-ID)\n\t\tprofileGroup :\u003d apiRoutes.Group(\"/perfiles\")\n\t\tprofileGroup.Use(api.AuthMiddleware()) // \u003c--- Aplica el middleware\n\t\t{\n\t\t\tprofileGroup.GET(\"\", api.GetMiPerfil)     // Obtiene el perfil propio\n\t\t\tprofileGroup.PUT(\"\", api.UpdateMiPerfil)  // Actualiza el perfil propio\n\t\t}\n\t}\n\t\n\t// Puerto (default 8081)\n\tport :\u003d os.Getenv(\"PORT\")\n\tif port \u003d\u003d \"\" {\n\t\tport \u003d \"8081\"\n\t}\n\t\n\tlog.Printf(\"🚀 Profile Service (Go) escuchando en el puerto %s\", port)\n\trouter.Run(\":\" + port)\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 43
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/ApiGatewayApplication.java",
      "timestamp": 1763160087889,
      "startOffset": 803,
      "endOffset": 1028,
      "codeContent": "// Builder para el NUEVO servicio de Perfiles (Go)\n    @Bean\n    public WebClient.Builder profileServiceWebClientBuilder() {\n        return WebClient.builder()\n                .baseUrl(\"http://profile-service-go:8081\");\n    }",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 6
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/controller/UsuarioAgregadoController.java",
      "timestamp": 1763160196147,
      "startOffset": 745,
      "endOffset": 841,
      "codeContent": "private final WebClient webClientTallerApi;\n    private final WebClient webClientProfileService;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 2
    },
    {
      "filePath": "/UsuarioAgregadoController.java",
      "timestamp": 1763160241789,
      "startOffset": 859,
      "endOffset": 879,
      "codeContent": "IntellijIdeaRulezzz ",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/controller/UsuarioAgregadoController.java",
      "timestamp": 1763160242986,
      "startOffset": 858,
      "endOffset": 1212,
      "codeContent": "    public UsuarioAgregadoController(WebClient.Builder webClientBuilder) {\n        // Creamos un WebClient que apunta al servicio \u0027taller-api-2\u0027\n        // \u0027taller-api-2\u0027 es el nombre del servicio en docker-compose.yml\n        this.webClientTallerApi \u003d webClientBuilder\n                .baseUrl(\"http://taller-api-2:8080\")\n                .build();\n    }",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 7
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/config/sas.java",
      "timestamp": 1763165431910,
      "startOffset": 0,
      "endOffset": 64,
      "codeContent": "package co.edu.uniquindio.gateway.config;\n\npublic class sas {\n}\n",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 5
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/config/sas.java",
      "timestamp": 1763165435048,
      "startOffset": 43,
      "endOffset": 1576,
      "codeContent": "import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.Customizer;\nimport org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;\nimport org.springframework.security.config.web.server.ServerHttpSecurity;\nimport org.springframework.security.web.server.SecurityWebFilterChain;\n\n@Configuration\n@EnableWebFluxSecurity // Importante: usar la versión WebFlux para Gateway\npublic class SecurityConfig {\n\n    @Bean\n    public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n        http\n            .authorizeExchange(exchanges -\u003e exchanges\n                // 1. Permite acceso PÚBLICO a los endpoints de Actuator\n                //    (para que Prometheus y Docker Health puedan verlos)\n                .pathMatchers(\"/actuator/**\").permitAll()\n                \n                // 2. (Opcional pero recomendado) Permite acceso a Keycloak\n                .pathMatchers(\"/realms/**\").permitAll()\n                \n                // 3. Todas las demás rutas (ej. /api/**) deben estar autenticadas.\n                .anyExchange().authenticated()\n            )\n            // 4. Habilita la validación de tokens JWT\n            .oauth2ResourceServer(oauth2 -\u003e oauth2\n                .jwt(Customizer.withDefaults())\n            )\n            // 5. Deshabilita CSRF para el gateway (es stateless)\n            .csrf(ServerHttpSecurity.CsrfSpec::disable);\n\n        return http.build();\n    }\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 35
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/config/SecurityConfig.java",
      "timestamp": 1763166394478,
      "startOffset": 70,
      "endOffset": 2973,
      "codeContent": "beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;\nimport org.springframework.security.config.web.server.ServerHttpSecurity;\nimport org.springframework.security.oauth2.jwt.JwtDecoders;\nimport org.springframework.security.oauth2.jwt.NimbusReactiveJwtDecoder;\nimport org.springframework.security.oauth2.jwt.ReactiveJwtDecoder;\nimport org.springframework.security.oauth2.jwt.JwtValidators;\nimport org.springframework.security.oauth2.core.DelegatingOAuth2TokenValidator;\nimport org.springframework.security.oauth2.core.OAuth2TokenValidator;\nimport org.springframework.security.oauth2.jwt.Jwt;\nimport org.springframework.security.web.server.SecurityWebFilterChain;\n\n@Configuration\n@EnableWebFluxSecurity\npublic class SecurityConfig {\n\n    // Inject the INTERNAL Docker URI for Keycloak\n    @Value(\"${spring.security.oauth2.resourceserver.jwt.issuer-uri}\")\n    private String issuerUri;\n\n    @Bean\n    public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http, ReactiveJwtDecoder reactiveJwtDecoder) {\n        http\n            .authorizeExchange(exchanges -\u003e exchanges\n                // 1. Permite acceso PÚBLICO a /actuator/** (arregla Prometheus)\n                .pathMatchers(\"/actuator/**\").permitAll()\n                .pathMatchers(\"/realms/**\").permitAll()\n                // 2. Protege todo lo demás\n                .anyExchange().authenticated()\n            )\n            .oauth2ResourceServer(oauth2 -\u003e oauth2\n                // 3. Usa nuestro decodificador manual\n                .jwt(jwt -\u003e jwt.jwtDecoder(reactiveJwtDecoder))\n            )\n            .csrf(ServerHttpSecurity.CsrfSpec::disable);\n\n        return http.build();\n    }\n\n    // --- INICIO DE LA CORRECCIÓN ---\n    // Esto crea el bean \u0027ReactiveJwtDecoder\u0027 que faltaba\n    @Bean\n    public ReactiveJwtDecoder reactiveJwtDecoder() {\n        \n        // 1. Crea un decoder que apunta al \u0027issuerUri\u0027 (http://keycloak:8080...)\n        //    Esto permite que el gateway arranque dentro de Docker.\n        NimbusReactiveJwtDecoder jwtDecoder \u003d (NimbusReactiveJwtDecoder)\n                JwtDecoders.fromIssuerLocation(issuerUri);\n\n        // 2. Esta es la clave: Obtenemos el validador por defecto (que checa la fecha/hora)\n        //    PERO lo creamos *sin* el validador de emisor (issuer).\n        OAuth2TokenValidator\u003cJwt\u003e defaultValidator \u003d JwtValidators.createDefault();\n\n        // 3. Le decimos al decoder que use solo el validador de fecha/hora.\n        //    Esto soluciona el error \u0027iss claim is not valid\u0027 de los tests\n        //    porque ya no le importa si el issuer es \u0027localhost\u0027 o \u0027keycloak\u0027.\n        jwtDecoder.setJwtValidator(defaultValidator);\n\n        return jwtDecoder;\n    }\n    // --- FIN DE LA CORRECCIÓN ---",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 63
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/config/TestConfig.java",
      "timestamp": 1763167650776,
      "startOffset": 303,
      "endOffset": 3614,
      "codeContent": "private final String keycloakUrl;\n    private final String keycloakRealm;\n    private final String keycloakClientId;\n    private final String keycloakClientSecret;\n    private final String adminUsername;\nprivate final String adminPassword;\n    private final String adminClientId;\n\n    private TestConfig() {\n        properties \u003d new Properties();\nloadProperties();\n        this.apiBaseUrl \u003d getProperty(\"api.base.url\", \"http://localhost:8080\");\n        this.keycloakUrl \u003d getProperty(\"keycloak.url\", \"http://localhost:8082\");\n        this.keycloakRealm \u003d getProperty(\"keycloak.realm\", \"taller\");\n        this.keycloakClientId \u003d getProperty(\"keycloak.client.id\", \"taller-api\");\nthis.keycloakClientSecret \u003d getProperty(\"keycloak.client.secret\", \"jx34gvJ7Vo9UwxLwsbLa1K3C58ZbjrLh\");\n        this.adminUsername \u003d getProperty(\"admin.username\", \"admin\");\n        this.adminPassword \u003d getProperty(\"admin.password\", \"admin123\");\n        this.adminClientId \u003d getProperty(\"admin.client.id\", \"admin-cli\");\n}\n\n    public static TestConfig getInstance() {\n        if (instance \u003d\u003d null) {\n            synchronized (TestConfig.class) {\n                if (instance \u003d\u003d null) {\n                    instance \u003d new TestConfig();\n}\n            }\n        }\n        return instance;\n}\n\n    private void loadProperties() {\n        try (InputStream input \u003d getClass().getClassLoader()\n                .getResourceAsStream(\"test.properties\")) {\n            if (input !\u003d null) {\n                properties.load(input);\n}\n        } catch (IOException e) {\n            System.err.println(\"No se pudo cargar test.properties\");\n}\n    }\n\n    private String getProperty(String key, String defaultValue) {\n        String envValue \u003d System.getenv(key.toUpperCase().replace(\".\", \"_\"));\nif (envValue !\u003d null \u0026\u0026 !envValue.isEmpty()) {\n            return envValue;\n}\n\n        String sysValue \u003d System.getProperty(key);\nif (sysValue !\u003d null \u0026\u0026 !sysValue.isEmpty()) {\n            return sysValue;\n}\n\n        return properties.getProperty(key, defaultValue);\n}\n\n    public String getKeycloakTokenUrl() {\n        return String.format(\"%s/realms/%s/protocol/openid-connect/token\",\n                keycloakUrl, keycloakRealm);\n}\n\n    public String getMasterTokenUrl() {\n        return String.format(\"%s/realms/master/protocol/openid-connect/token\",\n                keycloakUrl);\n}\n\n    public String getKeycloakUserInfoUrl() {\n        return String.format(\"%s/realms/%s/protocol/openid-connect/userinfo\",\n                keycloakUrl, keycloakRealm);\n}\n\n    public String getKeycloakLogoutUrl() {\n        return String.format(\"%s/realms/%s/protocol/openid-connect/logout\",\n                keycloakUrl, keycloakRealm);\n}\n\n    public String getUsersEndpoint() {\n        return apiBaseUrl + \"/api/usuarios\";\n}\n\n    public String getProfilesEndpoint() {\n        // ⬇️ --- MODIFICADO --- ⬇️\n        // Apuntamos al servicio de Go en el puerto 8081, no al stub de Java en 8080\n        return getProperty(\"profile.api.base.url\", \"http://localhost:8081\") + \"/api/perfiles\";\n    }\n\n    public String getPasswordEndpoint() {\n        return apiBaseUrl + \"/api/usuarios/password\";\n}\n\n    public String getHealthEndpoint() {\n        return apiBaseUrl + \"/actuator/health\";\n}\n\n    public String getMetricsEndpoint() {\n        return apiBaseUrl + \"/actuator/prometheus\";\n",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 98
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/TokenClient.java",
      "timestamp": 1763167661914,
      "startOffset": 99,
      "endOffset": 8507,
      "codeContent": "com.google.gson.Gson;\nimport com.google.gson.JsonObject;\nimport lombok.Getter;\nimport lombok.extern.slf4j.Slf4j;\nimport io.restassured.response.Response;\n\nimport java.time.Instant;\nimport java.util.Base64;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n@Slf4j\n@Getter\npublic class TokenClient {\n\n    private static TokenClient instance;\n\n    private final TestConfig config;\n    private final AuthClient authClient;\nprivate final ConcurrentMap\u003cString, TokenInfo\u003e tokenCache;\n    private final Gson gson; // 👈 AÑADIDO\n\n    private TokenClient() {\n        this.config \u003d TestConfig.getInstance();\nthis.authClient \u003d AuthClient.getInstance();\n        this.tokenCache \u003d new ConcurrentHashMap\u003c\u003e();\n        this.gson \u003d new Gson(); // 👈 AÑADIDO\n    }\n\n    public static TokenClient getInstance() {\n        if (instance \u003d\u003d null) {\n            synchronized (TokenClient.class) {\n                if (instance \u003d\u003d null) {\n                    instance \u003d new TokenClient();\n}\n            }\n        }\n        return instance;\n}\n\n    // ⬇️ --- NUEVO MÉTODO --- ⬇️\n    /**\n     * Obtiene el UserID del administrador, forzando un login si no está en caché.\n     */\n    public String getAdminUserId() {\n        // 1. Asegurarse de que el token de admin esté logueado y en caché\n        getAdminToken();\n        \n        // 2. Obtener la info de la caché\n        String adminUsername \u003d config.getAdminUsername();\nTokenInfo tokenInfo \u003d tokenCache.get(adminUsername);\n\n        if (tokenInfo \u003d\u003d null || tokenInfo.getUserId() \u003d\u003d null) {\n            log.error(\"No se pudo obtener el UserID del admin desde el token\");\n            throw new RuntimeException(\"Error al extraer UserID del token de admin\");\n        }\n        \n        return tokenInfo.getUserId();\n    }\n\n    // Metodo para obtener el token de cualquier usuario\n    public String getTokenForUser(String username, String password) {\n        return getToken(username, password);\n}\n\n    /**\n     * Obtiene un token de acceso para un usuario (del realm \u0027taller\u0027),\n     * usando la caché si aún no expiró.\n*/\n    public String getToken(String username, String password) {\n        String cacheKey \u003d username;\nTokenInfo tokenInfo \u003d tokenCache.get(cacheKey);\n\n        if (tokenInfo !\u003d null \u0026\u0026 !tokenInfo.isExpired()) {\n            log.debug(\"Reutilizando token en caché para usuario {}\", username);\nreturn tokenInfo.getAccessToken();\n        }\n\n        log.debug(\"Solicitando nuevo token para usuario {}\", username);\n        String newToken;\nint expiresIn \u003d 240; // fallback (4 min)\n\n        try {\n            // Llama al método por defecto de AuthClient (que usa realm \u0027taller\u0027 y client \u0027taller-api\u0027)\n            Response response \u003d authClient.requestTokenResponse(username, password);\nif (response.statusCode() \u003d\u003d 200) {\n                newToken \u003d response.jsonPath().getString(\"access_token\");\nInteger exp \u003d response.jsonPath().getInt(\"expires_in\");\n\n                if (exp !\u003d null \u0026\u0026 exp \u003e 0) {\n                    expiresIn \u003d exp;\n}\n\n                // ⬇️ --- MODIFICADO --- ⬇️\n                String userId \u003d parseUserIdFromToken(newToken);\n                tokenCache.put(cacheKey, new TokenInfo(newToken, expiresIn, userId));\nlog.debug(\"Nuevo token guardado en caché para {} (UserID: {}, expira en {}s)\", username, userId, expiresIn);\n                return newToken;\n} else {\n                log.warn(\"No se obtuvo token (status {}). Body: {}\", response.statusCode(), response.getBody().asString());\nreturn null;\n            }\n        } catch (Exception e) {\n            log.error(\"Error al solicitar token para {}: {}\", username, e.getMessage());\nthrow new RuntimeException(\"Error al comunicarse con Keycloak: \" + e.getMessage(), e);\n}\n    }\n\n    /**\n     * Obtiene el token del usuario administrador configurado en TestConfig.\n* --- MÉTODO CORREGIDO ---\n     * Llama al realm \u0027taller\u0027 usando el client_id \u0027taller-api\u0027, que SÍ tiene los scopes.\n*/\n    public String getAdminToken() {\n        // Usamos el username del admin como clave de caché\n        String cacheKey \u003d config.getAdminUsername();\nTokenInfo tokenInfo \u003d tokenCache.get(cacheKey);\n\n        if (tokenInfo !\u003d null \u0026\u0026 !tokenInfo.isExpired()) {\n            log.debug(\"Reutilizando token de admin en caché\");\nreturn tokenInfo.getAccessToken();\n        }\n\n        log.debug(\"Solicitando nuevo token de admin al realm \u0027{}\u0027 usando el cliente \u0027{}\u0027\",\n                config.getKeycloakRealm(), config.getKeycloakClientId());\nString newToken;\n        int expiresIn \u003d 240; // fallback\n\n        try {\n            // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n            // ⬇️⬇️⬇️ CORRECCIÓN APLICADA ⬇️⬇️⬇️\n            // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n            Response response \u003d authClient.requestTokenResponse(\n                    config.getAdminUsername(),\nconfig.getAdminPassword()\n            );\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n            // ⬆️⬆️⬆️ FIN DE LA CORRECCIÓN ⬆️⬆️⬆️\n            // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n            if (response.statusCode() \u003d\u003d 200) {\n                newToken \u003d response.jsonPath().getString(\"access_token\");\nInteger exp \u003d response.jsonPath().getInt(\"expires_in\");\n\n                if (exp !\u003d null \u0026\u0026 exp \u003e 0) {\n                    expiresIn \u003d exp;\n}\n\n                // ⬇️ --- MODIFICADO --- ⬇️\n                String userId \u003d parseUserIdFromToken(newToken);\n                tokenCache.put(cacheKey, new TokenInfo(newToken, expiresIn, userId));\nlog.debug(\"Nuevo token de ADMIN guardado en caché (UserID: {}, expira en {}s)\", userId, expiresIn);\n                return newToken;\n} else {\n                log.error(\"¡FALLO CRÍTICO! No se pudo obtener el token de administrador.\");\nlog.error(\"El realm \u0027{}\u0027 de Keycloak respondió con status {}. Body: {}\",\n                        config.getKeycloakRealm(), response.statusCode(), response.getBody().asString());\nthrow new RuntimeException(\"No se pudo obtener el token de administrador. Revisa la configuración.\");\n}\n        } catch (Exception e) {\n            log.error(\"Error al solicitar token de admin: {}\", e.getMessage());\nthrow new RuntimeException(\"Error al comunicarse con Keycloak (admin): \" + e.getMessage(), e);\n}\n    }\n\n    /**\n     * Invalida un token específico en caché (para forzar su renovación).\n*/\n    public void invalidateToken(String username) {\n        String cacheKey \u003d username;\ntokenCache.remove(cacheKey);\n        log.debug(\"Token invalidado para usuario {}\", username);\n    }\n\n    /**\n     * Limpia completamente la caché de tokens.\n*/\n    public void clearCache() {\n        tokenCache.clear();\n        log.debug(\"Caché de tokens limpiada\");\n}\n\n    // ⬇️ --- NUEVO MÉTODO --- ⬇️\n    /**\n     * Decodifica el payload de un JWT para extraer el \"sub\" (Subject),\n     * que es el UserID.\n     */\n    private String parseUserIdFromToken(String jwt) {\n        if (jwt \u003d\u003d null || jwt.isEmpty()) return null;\n        try {\n            String[] parts \u003d jwt.split(\"\\\\.\");\n            if (parts.length \u003c 2) return null;\n            \n            String payload \u003d new String(Base64.getUrlDecoder().decode(parts[1]));\n            JsonObject jsonPayload \u003d gson.fromJson(payload, JsonObject.class);\n            \n            if (jsonPayload.has(\"sub\")) {\n                return jsonPayload.get(\"sub\").getAsString();\n            }\n            return null;\n        } catch (Exception e) {\n            log.error(\"Error al decodificar JWT para extraer \u0027sub\u0027: {}\", e.getMessage());\n            return null;\n        }\n    }\n\n\n    @Getter\n    private static class TokenInfo {\n        private final String accessToken;\nprivate final Instant expirationTime;\n        private final String userId; // 👈 AÑADIDO\n        private static final int EXPIRATION_BUFFER_SECONDS \u003d 30;\n\n        // ⬇️ --- MODIFICADO --- ⬇️\npublic TokenInfo(String accessToken, int expiresInSeconds, String userId) {\n            this.accessToken \u003d accessToken;\n            this.userId \u003d userId; // 👈 AÑADIDO\nlong effectiveExpiresIn \u003d Math.max(expiresInSeconds - EXPIRATION_BUFFER_SECONDS, 1);\n            this.expirationTime \u003d Instant.now().plusSeconds(effectiveExpiresIn);\n}\n\n        public boolean isExpired() {\n            boolean expired \u003d Instant.now().isAfter(expirationTime);\nif (expired) {\n                log.debug(\"Token expirado (expiró en {})\", expirationTime);\n",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 227
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/TokenClient.java",
      "timestamp": 1763167661997,
      "startOffset": 5165,
      "endOffset": 5185,
      "codeContent": "                    ",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/ApiClient.java",
      "timestamp": 1763167689558,
      "startOffset": 428,
      "endOffset": 4579,
      "codeContent": "private ApiClient() {\n        this.config \u003d TestConfig.getInstance();\n        this.tokenClient \u003d TokenClient.getInstance();\n}\n\n    public static ApiClient getInstance() {\n        if (instance \u003d\u003d null) {\n            synchronized (ApiClient.class) {\n                if (instance \u003d\u003d null) {\n                    instance \u003d new ApiClient();\n}\n            }\n        }\n        return instance;\n}\n\n    public RequestSpecification baseRequest() {\n        return given()\n                .contentType(\"application/json\")\n                .accept(\"application/json\")\n                .log().all();\n}\n\n    public RequestSpecification authenticatedRequest(String token) {\n        return baseRequest()\n                .header(\"Authorization\", \"Bearer \" + token);\n}\n\n    // ⬇️ --- NUEVO MÉTODO --- ⬇️\n    /**\n     * Crea una request para el servicio de Perfiles (Go),\n     * que espera el header X-User-ID.\n     */\n    public RequestSpecification profileRequest(String userId) {\n        return baseRequest()\n                .header(\"X-User-ID\", userId);\n    }\n\n    public RequestSpecification adminRequest() {\n        String adminToken \u003d tokenClient.getAdminToken();\nreturn authenticatedRequest(adminToken);\n    }\n\n    public Response get(String endpoint) {\n        log.debug(\"GET: {}\", endpoint);\nreturn baseRequest()\n                .when()\n                .get(endpoint)\n                .then()\n                .log().all()\n                .extract().response();\n}\n\n    public Response getAuthenticated(String endpoint, String token) {\n        log.debug(\"GET (autenticado): {}\", endpoint);\nreturn authenticatedRequest(token)\n                .when()\n                .get(endpoint)\n                .then()\n                .log().all()\n                .extract().response();\n}\n\n    public Response post(String endpoint, Object body) {\n        log.debug(\"POST: {}\", endpoint);\nreturn baseRequest()\n                .body(body)\n                .when()\n                .post(endpoint)\n                .then()\n                .log().all()\n                .extract().response();\n}\n\n    public Response postAuthenticated(String endpoint, Object body, String token) {\n        log.debug(\"POST (autenticado): {}\", endpoint);\nreturn authenticatedRequest(token)\n                .body(body)\n                .when()\n                .post(endpoint)\n                .then()\n                .log().all()\n                .extract().response();\n}\n\n    public Response putAuthenticated(String endpoint, Object body, String token) {\n        log.debug(\"PUT (autenticado): {}\", endpoint);\nreturn authenticatedRequest(token)\n                .body(body)\n                .when()\n                .put(endpoint)\n                .then()\n                .log().all()\n                .extract().response();\n}\n\n    public Response patchAuthenticated(String endpoint, Object body, String token) {\n        log.debug(\"PATCH (autenticado): {}\", endpoint);\nreturn authenticatedRequest(token)\n                .body(body)\n                .when()\n                .patch(endpoint)\n                .then()\n                .log().all()\n                .extract().response();\n}\n\n    public Response deleteAuthenticated(String endpoint, String token) {\n        log.debug(\"DELETE (autenticado): {}\", endpoint);\nreturn authenticatedRequest(token)\n                .when()\n                .delete(endpoint)\n                .then()\n                .log().all()\n                .extract().response();\n}\n\n    // ⬇️ --- NUEVOS MÉTODOS --- ⬇️\n    \n    public Response getProfile(String endpoint, String userId) {\n        log.debug(\"GET (Profile Service): {}\", endpoint);\n        return profileRequest(userId)\n                .when()\n                .get(endpoint)\n                .then()\n                .log().all()\n                .extract().response();\n    }\n    \n    public Response putProfile(String endpoint, Object body, String userId) {\n        log.debug(\"PUT (Profile Service): {}\", endpoint);\n        return profileRequest(userId)\n                .body(body)\n                .when()\n                .put(endpoint)\n                .then()\n                .log().all()\n                .extract().response();\n    }\n}",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 140
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/steps/PerfilesSteps.java",
      "timestamp": 1763167708613,
      "startOffset": 674,
      "endOffset": 5730,
      "codeContent": "\n    // ⬇️ --- MODIFICADO --- ⬇️\n    private String userId; // Cambiamos userToken por userId\n\n    private UsersData.ProfileTestData profileData;\n    private Map\u003cString, Object\u003e profileMap;\n\npublic PerfilesSteps() {\n        this.config \u003d TestConfig.getInstance();\n        this.apiClient \u003d ApiClient.getInstance();\n        this.tokenClient \u003d TokenClient.getInstance();\n}\n\n    @Dado(\"que el servicio de perfiles está disponible\")\n    public void servicioPerfilesDisponible() {\n        // ⬇️ --- MODIFICADO --- ⬇️\n        // Hacemos ping al endpoint de health del servicio de Go\n        Response healthCheck \u003d apiClient.get(config.getProfilesEndpoint().replace(\"/api/perfiles\", \"/health\"));\nScenarioContext.setResponse(healthCheck); // Guardar respuesta\n        assertThat(\"Servicio de perfiles disponible\", healthCheck.statusCode(), is(200));\nlog.info(\"✓ Servicio perfiles OK (Go)\");\n    }\n\n    @Dado(\"que tengo un usuario autenticado en el sistema\")\n    public void usuarioAutenticado() {\n        // ⬇️ --- MODIFICADO --- ⬇️\n        // Obtenemos el UserID real del admin\n        this.userId \u003d tokenClient.getAdminUserId();\nassertThat(\"UserID de admin\", userId, notNullValue());\n        log.info(\"✓ Usuario autenticado (UserID: {})\", userId);\n    }\n\n    @Dado(\"que tengo datos válidos de un perfil nuevo\")\n    public void datosValidosPerfil() {\n        this.profileData \u003d UsersData.generateRandomProfile();\nthis.profileMap \u003d UsersData.profileToMap(profileData);\n        log.info(\"✓ Datos perfil generados\");\n    }\n\n    @Dado(\"que el usuario tiene un perfil creado\")\n    public void perfilCreado() {\n        profileData \u003d UsersData.generateRandomProfile();\nprofileMap \u003d UsersData.profileToMap(profileData);\n\n        // ⬇️ --- MODIFICADO --- ⬇️\n        // Usamos PUT (como lo hace el servicio de Go) para crearlo\n        Response creationResponse \u003d apiClient.putProfile(\n                config.getProfilesEndpoint(), profileMap, userId);\nScenarioContext.setResponse(creationResponse);\nif (creationResponse.statusCode() \u003d\u003d 200) { // Go devuelve 200 para PUT\n            log.info(\"✓ Perfil creado/actualizado para el step\");\n}\n    }\n\n    @Dado(\"que tengo nuevos datos para actualizar el perfil\")\n    public void nuevosDatosActualizarPerfil() {\n        profileData \u003d UsersData.generateRandomProfile();\nprofileMap \u003d UsersData.profileToMap(profileData);\n        log.info(\"✓ Datos actualización\");\n    }\n\n    @Cuando(\"envío una solicitud para crear el perfil\")\n    public void crearPerfil() {\n        // ⬇️ --- MODIFICADO --- ⬇️\n        // El servicio de Go usa PUT para crear, no POST\n        Response apiResponse \u003d apiClient.putProfile(\n                config.getProfilesEndpoint(), profileMap, userId);\nScenarioContext.setResponse(apiResponse); // Guardar respuesta\n        log.info(\"✓ Crear/Actualizar perfil (enviando PUT)\");\n}\n\n    @Cuando(\"envío una solicitud para obtener mi perfil\")\n    public void obtenerPerfil() {\n        // ⬇️ --- MODIFICADO --- ⬇️\n        // Usamos el método que envía X-User-ID\n        Response apiResponse \u003d apiClient.getProfile(\n                config.getProfilesEndpoint(), userId);\nScenarioContext.setResponse(apiResponse); // Guardar respuesta\n        log.info(\"✓ Obtener perfil\");\n}\n\n    @Cuando(\"envío una solicitud para actualizar mi perfil\")\n    public void actualizarPerfil() {\n        // ⬇️ --- MODIFICADO --- ⬇️\n        // Usamos el método que envía X-User-ID\n        Response apiResponse \u003d apiClient.putProfile(\n                config.getProfilesEndpoint(), profileMap, userId);\nScenarioContext.setResponse(apiResponse); // Guardar respuesta\n        log.info(\"✓ Actualizar perfil\");\n}\n\n    @Entonces(\"el perfil debe ser creado exitosamente\")\n    public void perfilCreadoExitosamente() {\n        Response responseFromContext \u003d ScenarioContext.getResponse();\nString id \u003d responseFromContext.jsonPath().getString(\"userId\");\nassertThat(\"Perfil creado\", id, notNullValue());\n        assertThat(\"ID coincide\", id, is(userId)); // Verificamos que sea nuestro ID\nlog.info(\"✓ Perfil ID: {}\", id);\n    }\n\n    @Entonces(\"la respuesta debe cumplir con el esquema de perfil\")\n    public void respuestaCumpleEsquemaPerfil() {\n        Response responseFromContext \u003d ScenarioContext.getResponse();\n// Leer respuesta\n        assertThat(\"Tiene apodo\", responseFromContext.jsonPath().get(\"apodo\"), notNullValue());\n        log.info(\"✓ Esquema perfil OK\");\n}\n\n    @Entonces(\"debo recibir los datos de mi perfil\")\n    public void datosDelPerfil() {\n        Response responseFromContext \u003d ScenarioContext.getResponse();\n// Leer respuesta\n        assertThat(\"Datos perfil\", responseFromContext.jsonPath().get(\"apodo\"), notNullValue());\n        log.info(\"✓ Datos perfil OK\");\n}\n\n    @Entonces(\"el perfil debe actualizarse con los nuevos datos\")\n    public void perfilActualizado() {\n        Response responseFromContext \u003d ScenarioContext.getResponse();\n// Leer respuesta\n        String apodo \u003d responseFromContext.jsonPath().getString(\"apodo\");\n        assertThat(\"Actualizado\", apodo, notNullValue());\n        log.info(\"✓ Perfil actualizado\");\n",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 124
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/config/TestConfig.java",
      "timestamp": 1763179807498,
      "startOffset": 3258,
      "endOffset": 3567,
      "codeContent": "CIÓN --- ⬇️\n        // Ahora apuntamos al API Gateway (apiBaseUrl), no al servicio de Go.\n        // El Gateway se encargará de enrutar a \"http://profile-service-go:8081\"\n        // y de inyectar el header X-User-ID.\n        return apiBaseUrl + \"/api/perfiles\";\n        // ⬆️ --- FIN DE LA MODIFICACIÓN --- ⬆️",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 6
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/steps/PerfilesSteps.java",
      "timestamp": 1763179856365,
      "startOffset": 711,
      "endOffset": 6540,
      "codeContent": "// Cambiamos userId por adminToken.\n    // Necesitamos el token para que el Gateway pueda extraer el \u0027sub\u0027 (userId)\n    private String adminToken;\n    // ⬆️ --- FIN DE LA MODIFICACIÓN --- ⬆️\n\n    private UsersData.ProfileTestData profileData;\n    private Map\u003cString, Object\u003e profileMap;\n\n    public PerfilesSteps() {\n        this.config \u003d TestConfig.getInstance();\n        this.apiClient \u003d ApiClient.getInstance();\n        this.tokenClient \u003d TokenClient.getInstance();\n    }\n\n    @Dado(\"que el servicio de perfiles está disponible\")\n    public void servicioPerfilesDisponible() {\n        // ⬇️ --- MODIFICADO --- ⬇️\n        // Hacemos ping al endpoint de health del API Gateway (o del servicio principal)\n        // ya que es un prerrequisito para que la ruta de perfiles funcione.\n        Response healthCheck \u003d apiClient.get(config.getHealthEndpoint());\n        ScenarioContext.setResponse(healthCheck); // Guardar respuesta\n        assertThat(\"API Gateway (prerrequisito) disponible\", healthCheck.statusCode(), is(200));\n        log.info(\"✓ Prerrequisito (API Gateway) OK\");\n        // ⬆️ --- FIN DE LA MODIFICACIÓN --- ⬆️\n    }\n\n    @Dado(\"que tengo un usuario autenticado en el sistema\")\n    public void usuarioAutenticado() {\n        // ⬇️ --- MODIFICADO --- ⬇️\n        // Obtenemos el Token de admin, no el UserID\n        this.adminToken \u003d tokenClient.getAdminToken();\n        assertThat(\"Token de admin\", adminToken, notNullValue());\n        log.info(\"✓ Usuario autenticado (token obtenido)\");\n        // ⬆️ --- FIN DE LA MODIFICACIÓN --- ⬆️\n    }\n\n    @Dado(\"que tengo datos válidos de un perfil nuevo\")\n    public void datosValidosPerfil() {\n        this.profileData \u003d UsersData.generateRandomProfile();\n        this.profileMap \u003d UsersData.profileToMap(profileData);\n        log.info(\"✓ Datos perfil generados\");\n    }\n\n    @Dado(\"que el usuario tiene un perfil creado\")\n    public void perfilCreado() {\n        profileData \u003d UsersData.generateRandomProfile();\n        profileMap \u003d UsersData.profileToMap(profileData);\n\n        // ⬇️ --- MODIFICADO --- ⬇️\n        // Usamos el método autenticado estándar (con token)\n        Response creationResponse \u003d apiClient.putAuthenticated(\n                config.getProfilesEndpoint(), profileMap, adminToken);\n        // ⬆️ --- FIN DE LA MODIFICACIÓN --- ⬆️\n\n        ScenarioContext.setResponse(creationResponse);\n        if (creationResponse.statusCode() \u003d\u003d 200) { // Go devuelve 200 para PUT\n            log.info(\"✓ Perfil creado/actualizado para el step\");\n        }\n    }\n\n    @Dado(\"que tengo nuevos datos para actualizar el perfil\")\n    public void nuevosDatosActualizarPerfil() {\n        profileData \u003d UsersData.generateRandomProfile();\n        this.profileMap \u003d UsersData.profileToMap(profileData);\n        log.info(\"✓ Datos actualización\");\n    }\n\n    @Cuando(\"envío una solicitud para crear el perfil\")\n    public void crearPerfil() {\n        // ⬇️ --- MODIFICADO --- ⬇️\n        // Usamos el método autenticado estándar (con token)\n        Response apiResponse \u003d apiClient.putAuthenticated(\n                config.getProfilesEndpoint(), profileMap, adminToken);\n        ScenarioContext.setResponse(apiResponse); // Guardar respuesta\n        log.info(\"✓ Crear/Actualizar perfil (enviando PUT a Gateway)\");\n        // ⬆️ --- FIN DE LA MODIFICACIÓN --- ⬆️\n    }\n\n    @Cuando(\"envío una solicitud para obtener mi perfil\")\n    public void obtenerPerfil() {\n        // ⬇️ --- MODIFICADO --- ⬇️\n        // Usamos el método autenticado estándar (con token)\n        Response apiResponse \u003d apiClient.getAuthenticated(\n                config.getProfilesEndpoint(), adminToken);\n        ScenarioContext.setResponse(apiResponse); // Guardar respuesta\n        log.info(\"✓ Obtener perfil (vía Gateway)\");\n        // ⬆️ --- FIN DE LA MODIFICACIÓN --- ⬆️\n    }\n\n    @Cuando(\"envío una solicitud para actualizar mi perfil\")\n    public void actualizarPerfil() {\n        // ⬇️ --- MODIFICADO --- ⬇️\n        // Usamos el método autenticado estándar (con token)\n        Response apiResponse \u003d apiClient.putAuthenticated(\n                config.getProfilesEndpoint(), profileMap, adminToken);\n        ScenarioContext.setResponse(apiResponse); // Guardar respuesta\n        log.info(\"✓ Actualizar perfil (vía Gateway)\");\n        // ⬆️ --- FIN DE LA MODIFICACIÓN --- ⬆️\n    }\n\n    @Entonces(\"el perfil debe ser creado exitosamente\")\n    public void perfilCreadoExitosamente() {\n        Response responseFromContext \u003d ScenarioContext.getResponse();\n        String id \u003d responseFromContext.jsonPath().getString(\"userId\");\n        assertThat(\"Perfil creado (userId no nulo)\", id, notNullValue());\n        \n        // ⬇️ --- MODIFICADO --- ⬇️\n        // Verificamos que el ID del perfil coincida con el ID del token que usamos.\n        String expectedUserId \u003d tokenClient.getAdminUserId(); // Obtenemos el ID real del token\n        assertThat(\"ID coincide con el token\", id, is(expectedUserId));\n        log.info(\"✓ Perfil ID: {}\", id);\n        // ⬆️ --- FIN DE LA MODIFICACIÓN --- ⬆️\n    }\n\n    @Entonces(\"la respuesta debe cumplir con el esquema de perfil\")\n    public void respuestaCumpleEsquemaPerfil() {\n        Response responseFromContext \u003d ScenarioContext.getResponse();\n        assertThat(\"Tiene apodo\", responseFromContext.jsonPath().get(\"apodo\"), notNullValue());\n        log.info(\"✓ Esquema perfil OK\");\n    }\n\n    @Entonces(\"debo recibir los datos de mi perfil\")\n    public void datosDelPerfil() {\n        Response responseFromContext \u003d ScenarioContext.getResponse();\n        assertThat(\"Datos perfil\", responseFromContext.jsonPath().get(\"apodo\"), notNullValue());\n        log.info(\"✓ Datos perfil OK\");\n    }\n\n    @Entonces(\"el perfil debe actualizarse con los nuevos datos\")\n    public void perfilActualizado() {\n        Response responseFromContext \u003d ScenarioContext.getResponse();",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 131
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/config/SecurityConfig.java",
      "timestamp": 1763181279860,
      "startOffset": 379,
      "endOffset": 4607,
      "codeContent": "import org.springframework.security.oauth2.jwt.JwtValidators;\nimport org.springframework.security.oauth2.jwt.NimbusReactiveJwtDecoder;\nimport org.springframework.security.oauth2.jwt.ReactiveJwtDecoder;\nimport org.springframework.security.oauth2.core.DelegatingOAuth2TokenValidator;\nimport org.springframework.security.oauth2.core.OAuth2TokenValidator;\nimport org.springframework.security.oauth2.jwt.Jwt;\nimport org.springframework.security.web.server.SecurityWebFilterChain;\n\n// --- Imports Añadidos ---\nimport org.springframework.cloud.gateway.filter.GlobalFilter;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.http.server.reactive.ServerHttpRequest;\nimport org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;\nimport org.springframework.web.server.ServerWebExchange;\n// --- Fin Imports Añadidos ---\n\n@Configuration\n@EnableWebFluxSecurity\npublic class SecurityConfig {\n\n    @Value(\"${spring.security.oauth2.resourceserver.jwt.jwk-set-uri}\")\n    private String jwkSetUri;\n\n    @Bean\n    public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http, ReactiveJwtDecoder reactiveJwtDecoder) {\n        http\n                .authorizeExchange(exchanges -\u003e exchanges\n                        .pathMatchers(\"/actuator/**\").permitAll()\n                        .pathMatchers(\"/realms/**\").permitAll()\n                        .anyExchange().authenticated()\n                )\n                .oauth2ResourceServer(oauth2 -\u003e oauth2\n                        .jwt(jwt -\u003e jwt.jwtDecoder(reactiveJwtDecoder))\n                )\n                .csrf(ServerHttpSecurity.CsrfSpec::disable);\n        return http.build();\n    }\n\n    @Bean\n    public ReactiveJwtDecoder reactiveJwtDecoder() {\n        NimbusReactiveJwtDecoder jwtDecoder \u003d new NimbusReactiveJwtDecoder(this.jwkSetUri);\n        OAuth2TokenValidator\u003cJwt\u003e defaultValidator \u003d JwtValidators.createDefault();\n        jwtDecoder.setJwtValidator(defaultValidator);\n        return jwtDecoder;\n    }\n\n    // ⬇️ --- ESTA ES LA NUEVA SOLUCIÓN --- ⬇️\n\n    /**\n     * Filtro global que se ejecuta DESPUÉS de la autenticación.\n     * Si la ruta es para \u0027/api/perfiles\u0027, extrae el ID de usuario (claim \u0027sub\u0027) \n     * del token y lo inyecta en el header \u0027X-User-ID\u0027 para el servicio de Go.\n     */\n    @Bean\n    @Order(Ordered.LOWEST_PRECEDENCE) // Se ejecuta después de los filtros de seguridad\n    public GlobalFilter addUserIdHeaderFilter() {\n        return (exchange, chain) -\u003e {\n            \n            // 1. Comprobar si la ruta es la de perfiles\n            if (exchange.getRequest().getPath().value().startsWith(\"/api/perfiles\")) {\n\n                // 2. Obtener el Principal (usuario autenticado) del contexto\n                return exchange.getPrincipal()\n                        .flatMap(principal -\u003e {\n                            String userId \u003d null;\n                            \n                            // 3. Extraer el ID de usuario (claim \u0027sub\u0027) del token JWT\n                            if (principal instanceof JwtAuthenticationToken) {\n                                Jwt jwt \u003d ((JwtAuthenticationToken) principal).getToken();\n                                userId \u003d jwt.getClaimAsString(\"sub\");\n                            }\n\n                            // 4. Si encontramos el ID, mutar la petición\n                            if (userId !\u003d null) {\n                                ServerHttpRequest request \u003d exchange.getRequest().mutate()\n                                        .header(\"X-User-ID\", userId)\n                                        .build();\n                                ServerWebExchange newExchange \u003d exchange.mutate().request(request).build();\n                                return chain.filter(newExchange);\n                            }\n                            \n                            // Si no hay ID (raro), continuar sin modificar\n                            return chain.filter(exchange);\n                        });\n            }\n            \n            // Si no es la ruta de perfiles, no hacer nada.\n            return chain.filter(exchange);\n        };\n    }\n    // ⬆️ --- FIN DE LA NUEVA SOLUCIÓN --- ⬆️",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 92
    }
  ],
  "toolStats": {
    "GitHub Copilot": {
      "usageCount": 109,
      "totalLines": 3571
    }
  }
}