{
  "version": "1.0",
  "records": [
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/ApiGatewayApplication.java",
      "timestamp": 1763017605929,
      "startOffset": 0,
      "endOffset": 75,
      "codeContent": "package co.edu.uniquindio.gateway;\n\npublic class ApiGatewayApplication {\n}\n",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 5
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/ApiGatewayApplication.java",
      "timestamp": 1763017610498,
      "startOffset": 36,
      "endOffset": 505,
      "codeContent": "import org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n\n@SpringBootApplication\n@EnableDiscoveryClient // Habilita el descubrimiento de servicios (aunque usemos el de Docker)\npublic class ApiGatewayApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ApiGatewayApplication.class, args);\n    }\n\n}",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 13
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/config/TestConfig.java",
      "timestamp": 1763021572511,
      "startOffset": 2547,
      "endOffset": 2809,
      "codeContent": "/** URL completa del endpoint /token del realm MASTER */\n    public String getMasterTokenUrl() {\n        // Usa \"master\" en lugar de keycloakRealm\n        return String.format(\"%s/realms/master/protocol/openid-connect/token\",\n                keycloakUrl); \n    }",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 6
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/TokenClient.java",
      "timestamp": 1763021672919,
      "startOffset": 3726,
      "endOffset": 6231,
      "codeContent": "String cacheKey \u003d \"admin_master_token\"; // Clave de caché específica para el admin\n        TokenInfo tokenInfo \u003d tokenCache.get(cacheKey);\n\n        // Si el token de admin existe y NO ha expirado, lo usamos\n        if (tokenInfo !\u003d null \u0026\u0026 !tokenInfo.isExpired()) {\n            log.debug(\"Reutilizando token de admin en caché\");\n            return tokenInfo.getAccessToken();\n        }\n\n        // Si no hay token o expiró, pedimos uno nuevo AL REALM MASTER\n        log.debug(\"Solicitando nuevo token de admin al realm \u0027master\u0027\");\n        String newToken;\n        int expiresIn \u003d 240; // fallback\n\n        try {\n            // 1. Obtenemos la URL del realm \u0027master\u0027 (del TestConfig)\n            String masterTokenUrl \u003d config.getMasterTokenUrl();\n\n            // 2. Llamamos al método SOBRECARGADO de AuthClient\n            Response response \u003d authClient.requestTokenResponse(\n                    config.getAdminUsername(),\n                    config.getAdminPassword(),\n                    masterTokenUrl // \u003c-- ¡La URL explícita del realm \u0027master\u0027!\n            );\n\n            if (response.statusCode() \u003d\u003d 200) {\n                newToken \u003d response.jsonPath().getString(\"access_token\");\n                Integer exp \u003d response.jsonPath().getInt(\"expires_in\");\n\n                if (exp !\u003d null \u0026\u0026 exp \u003e 0) {\n                    expiresIn \u003d exp;\n                }\n\n                // Guardar el token de admin en caché\n                tokenCache.put(cacheKey, new TokenInfo(newToken, expiresIn));\n                log.debug(\"Nuevo token de ADMIN guardado en caché (expira en {}s)\", expiresIn);\n                return newToken;\n            } else {\n                // Manejar error de autenticación (ej. 401 Unauthorized)\n                log.error(\"¡FALLO CRÍTICO! No se pudo obtener el token de administrador.\");\n                log.error(\"El realm \u0027master\u0027 de Keycloak en {} respondió con status {}. Body: {}\",\n                        masterTokenUrl, response.statusCode(), response.getBody().asString());\n                log.error(\"Verifica las credenciales \u0027admin.username\u0027 y \u0027admin.password\u0027 en test.properties y que Keycloak esté corriendo.\");\n                throw new RuntimeException(\"No se pudo obtener el token de administrador. Revisa la configuración.\");\n            }\n        } catch (Exception e) {\n            log.error(\"Error al solicitar token de admin: {}\", e.getMessage());\n            throw new RuntimeException(\"Error al comunicarse con Keycloak (master): \" + e.getMessage());\n        }",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 49
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/AuthClient.java",
      "timestamp": 1763021687648,
      "startOffset": 140,
      "endOffset": 4587,
      "codeContent": "io.restassured.http.ContentType; // Importa ContentType\nimport lombok.extern.slf4j.Slf4j;\n\nimport static io.restassured.RestAssured.given;\n\n/**\n * Cliente encargado de manejar la autenticación y obtener información del usuario\n * desde Keycloak (u otro servidor compatible con OpenID Connect).\n */\n@Slf4j\npublic class AuthClient {\n\n    private static AuthClient instance;\n\n    // Estos son los valores por DEFECTO (para el realm \u0027taller\u0027)\n    private final String defaultTokenUrl;\n    private final String clientId;\n    private final String clientSecret;\n    private final String userInfoUrl;\n\n    private AuthClient() {\n        TestConfig config \u003d TestConfig.getInstance();\n        // Renombrado de tokenUrl a defaultTokenUrl para mayor claridad\n        this.defaultTokenUrl \u003d config.getKeycloakTokenUrl(); \n        this.clientId \u003d config.getKeycloakClientId();\n        this.clientSecret \u003d config.getKeycloakClientSecret();\n        this.userInfoUrl \u003d config.getKeycloakUserInfoUrl();\n    }\n\n    public static AuthClient getInstance() {\n        if (instance \u003d\u003d null) {\n            synchronized (AuthClient.class) {\n                if (instance \u003d\u003d null) {\n                    instance \u003d new AuthClient();\n                }\n            }\n        }\n        return instance;\n    }\n\n    /**\n     * --- MÉTODO ANTIGUO (MODIFICADO) ---\n     * Realiza la petición al token endpoint POR DEFECTO (realm \u0027taller\u0027).\n     * Ahora delega la llamada al nuevo método sobrecargado.\n     */\n    public Response requestTokenResponse(String username, String password) {\n        log.debug(\"Solicitando token (por defecto) para user\u003d{}\", username);\n        // Llama al método de trabajo principal usando la URL por defecto\n        return requestTokenResponse(username, password, this.defaultTokenUrl);\n    }\n\n    /**\n     * --- MÉTODO NUEVO (SOBRECARGADO) ---\n     * Esta es la corrección clave.\n     * Realiza la petición al token endpoint en una URL ESPECÍFICA.\n     * Lo usaremos para llamar al realm \u0027master\u0027 cuando pidamos el token de admin.\n     */\n    public Response requestTokenResponse(String username, String password, String specificTokenUrl) {\n        log.debug(\"Solicitando token para user\u003d{} en URL\u003d{}\", username, specificTokenUrl);\n\n        Response response \u003d given()\n                // Corregido: RestAssured recomienda ContentType.URLENC\n                .contentType(ContentType.URLENC) \n                .formParam(\"grant_type\", \"password\")\n                .formParam(\"client_id\", clientId)\n                .formParam(\"client_secret\", clientSecret)\n                .formParam(\"username\", username)\n                .formParam(\"password\", password)\n                .when()\n                .post(specificTokenUrl); // \u003c-- Usa la URL específica\n\n        log.debug(\"Token endpoint → status\u003d{} body\u003d{}\",\n                response.statusCode(), safeBody(response));\n\n        return response;\n    }\n\n\n    /**\n     * Obtiene el access_token y lanza excepción si la respuesta no es exitosa.\n     * (Este método no cambia, seguirá usando el realm por defecto \u0027taller\u0027)\n     */\n    public String getAccessToken(String username, String password) {\n        Response r \u003d requestTokenResponse(username, password); // Llama al método por defecto\n        if (r.statusCode() !\u003d 200) {\n            log.error(\"Error obteniendo token. Status: {}, Body: {}\", r.statusCode(), safeBody(r));\n            throw new RuntimeException(\"No se pudo obtener el token de acceso. Status: \" + r.statusCode());\n        }\n        String token \u003d r.jsonPath().getString(\"access_token\");\n        log.debug(\"Token obtenido correctamente para {} ({} caracteres)\", username, token !\u003d null ? token.length() : 0);\n        return token;\n    }\n\n    /**\n     * Llama al endpoint userinfo con el token proporcionado.\n     * (Este método no cambia)\n     */\n    public Response getUserInfo(String accessToken) {\n        log.debug(\"Llamando al endpoint userinfo\");\n        Response response \u003d given()\n                .header(\"Authorization\", \"Bearer \" + accessToken)\n                .when()\n                .get(userInfoUrl);\n\n        log.debug(\"Userinfo → status\u003d{} body\u003d{}\", response.statusCode(), safeBody(response));\n        return response;\n    }\n\n    private String safeBody(Response response) {\n        try {\n            return response.getBody() !\u003d null ? response.getBody().asString() : \"(sin cuerpo)\";\n        } catch (Exception e) {\n            return \"(error leyendo body)\";\n        }\n    }\n}",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 116
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/config/TestConfig.java",
      "timestamp": 1763021986753,
      "startOffset": 555,
      "endOffset": 590,
      "codeContent": "private final String adminClientId;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/config/TestConfig.java",
      "timestamp": 1763022049686,
      "startOffset": 4054,
      "endOffset": 4126,
      "codeContent": "public java.lang.String getAdminPassword() {\n    return adminPassword;\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 3
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/config/TestConfig.java",
      "timestamp": 1763022049701,
      "startOffset": 4116,
      "endOffset": 4188,
      "codeContent": "public java.lang.String getAdminUsername() {\n    return adminUsername;\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 3
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/config/TestConfig.java",
      "timestamp": 1763022049715,
      "startOffset": 4178,
      "endOffset": 4264,
      "codeContent": "public java.lang.String getKeycloakClientSecret() {\n    return keycloakClientSecret;\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 3
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/config/TestConfig.java",
      "timestamp": 1763022049728,
      "startOffset": 4254,
      "endOffset": 4332,
      "codeContent": "public java.lang.String getKeycloakClientId() {\n    return keycloakClientId;\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 3
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/config/TestConfig.java",
      "timestamp": 1763022049741,
      "startOffset": 4322,
      "endOffset": 4394,
      "codeContent": "public java.lang.String getKeycloakRealm() {\n    return keycloakRealm;\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 3
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/config/TestConfig.java",
      "timestamp": 1763022049755,
      "startOffset": 4384,
      "endOffset": 4452,
      "codeContent": "public java.lang.String getKeycloakUrl() {\n    return keycloakUrl;\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 3
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/config/TestConfig.java",
      "timestamp": 1763022049770,
      "startOffset": 4442,
      "endOffset": 4508,
      "codeContent": "public java.lang.String getApiBaseUrl() {\n    return apiBaseUrl;\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 3
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/config/TestConfig.java",
      "timestamp": 1763022049784,
      "startOffset": 4498,
      "endOffset": 4568,
      "codeContent": "public java.util.Properties getProperties() {\n    return properties;\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 3
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/config/TestConfig.java",
      "timestamp": 1763022049796,
      "startOffset": 4558,
      "endOffset": 4680,
      "codeContent": "public static void setInstance(co.edu.uniquindio.tests.config.TestConfig instance) {\n    TestConfig.instance \u003d instance;\n}",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 3
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/AuthClient.java",
      "timestamp": 1763022145002,
      "startOffset": 231,
      "endOffset": 252,
      "codeContent": "import java.util.Map;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/AuthClient.java",
      "timestamp": 1763022147648,
      "startOffset": 231,
      "endOffset": 256,
      "codeContent": "import java.util.HashMap;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/AuthClient.java",
      "timestamp": 1763022220673,
      "startOffset": 512,
      "endOffset": 2875,
      "codeContent": "\n    // Estos son los valores por DEFECTO (para el realm \u0027taller\u0027)\n    private final String defaultTokenUrl;\n    private final String clientId;\n    private final String clientSecret;\n    private final String userInfoUrl;\n\n    private AuthClient() {\n        TestConfig config \u003d TestConfig.getInstance();\n        // Renombrado de tokenUrl a defaultTokenUrl para mayor claridad\n        this.defaultTokenUrl \u003d config.getKeycloakTokenUrl();\n        this.clientId \u003d config.getKeycloakClientId();\n        this.clientSecret \u003d config.getKeycloakClientSecret();\n        this.userInfoUrl \u003d config.getKeycloakUserInfoUrl();\n    }\n\n    public static AuthClient getInstance() {\n        if (instance \u003d\u003d null) {\n            synchronized (AuthClient.class) {\n                if (instance \u003d\u003d null) {\n                    instance \u003d new AuthClient();\n                }\n            }\n        }\n        return instance;\n    }\n\n    /**\n     * --- MÉTODO ANTIGUO (MODIFICADO) ---\n     * Realiza la petición al token endpoint POR DEFECTO (realm \u0027taller\u0027).\n     * Ahora delega la llamada al nuevo método sobrecargado.\n     */\n    public Response requestTokenResponse(String username, String password) {\n        log.debug(\"Solicitando token (por defecto) para user\u003d{}\", username);\n        // Llama al método de trabajo principal usando la URL por defecto\n        return requestTokenResponse(username, password, this.defaultTokenUrl);\n    }\n\n    /**\n     * --- MÉTODO NUEVO (SOBRECARGADO) ---\n     * Esta es la corrección clave.\n     * Realiza la petición al token endpoint en una URL ESPECÍFICA.\n     * Lo usaremos para llamar al realm \u0027master\u0027 cuando pidamos el token de admin.\n     */\n    public Response requestTokenResponse(String username, String password, String specificTokenUrl) {\n        log.debug(\"Solicitando token para user\u003d{} en URL\u003d{}\", username, specificTokenUrl);\n\n        Response response \u003d given()\n                // Corregido: RestAssured recomienda ContentType.URLENC\n                .contentType(ContentType.URLENC)\n                .formParam(\"grant_type\", \"password\")\n                .formParam(\"client_id\", clientId)\n                .formParam(\"client_secret\", clientSecret)\n                .formParam(\"username\", username)\n                .formParam(\"password\", password)\n                .when()\n                .post(specificTokenUrl); // \u003c-- Usa la URL específica",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 57
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/AuthClient.java",
      "timestamp": 1763022225233,
      "startOffset": 512,
      "endOffset": 2875,
      "codeContent": "\n    // Estos son los valores por DEFECTO (para el realm \u0027taller\u0027)\n    private final String defaultTokenUrl;\n    private final String clientId;\n    private final String clientSecret;\n    private final String userInfoUrl;\n\n    private AuthClient() {\n        TestConfig config \u003d TestConfig.getInstance();\n        // Renombrado de tokenUrl a defaultTokenUrl para mayor claridad\n        this.defaultTokenUrl \u003d config.getKeycloakTokenUrl();\n        this.clientId \u003d config.getKeycloakClientId();\n        this.clientSecret \u003d config.getKeycloakClientSecret();\n        this.userInfoUrl \u003d config.getKeycloakUserInfoUrl();\n    }\n\n    public static AuthClient getInstance() {\n        if (instance \u003d\u003d null) {\n            synchronized (AuthClient.class) {\n                if (instance \u003d\u003d null) {\n                    instance \u003d new AuthClient();\n                }\n            }\n        }\n        return instance;\n    }\n\n    /**\n     * --- MÉTODO ANTIGUO (MODIFICADO) ---\n     * Realiza la petición al token endpoint POR DEFECTO (realm \u0027taller\u0027).\n     * Ahora delega la llamada al nuevo método sobrecargado.\n     */\n    public Response requestTokenResponse(String username, String password) {\n        log.debug(\"Solicitando token (por defecto) para user\u003d{}\", username);\n        // Llama al método de trabajo principal usando la URL por defecto\n        return requestTokenResponse(username, password, this.defaultTokenUrl);\n    }\n\n    /**\n     * --- MÉTODO NUEVO (SOBRECARGADO) ---\n     * Esta es la corrección clave.\n     * Realiza la petición al token endpoint en una URL ESPECÍFICA.\n     * Lo usaremos para llamar al realm \u0027master\u0027 cuando pidamos el token de admin.\n     */\n    public Response requestTokenResponse(String username, String password, String specificTokenUrl) {\n        log.debug(\"Solicitando token para user\u003d{} en URL\u003d{}\", username, specificTokenUrl);\n\n        Response response \u003d given()\n                // Corregido: RestAssured recomienda ContentType.URLENC\n                .contentType(ContentType.URLENC)\n                .formParam(\"grant_type\", \"password\")\n                .formParam(\"client_id\", clientId)\n                .formParam(\"client_secret\", clientSecret)\n                .formParam(\"username\", username)\n                .formParam(\"password\", password)\n                .when()\n                .post(specificTokenUrl); // \u003c-- Usa la URL específica",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 57
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/AuthClient.java",
      "timestamp": 1763022228273,
      "startOffset": 512,
      "endOffset": 2875,
      "codeContent": "\n    // Estos son los valores por DEFECTO (para el realm \u0027taller\u0027)\n    private final String defaultTokenUrl;\n    private final String clientId;\n    private final String clientSecret;\n    private final String userInfoUrl;\n\n    private AuthClient() {\n        TestConfig config \u003d TestConfig.getInstance();\n        // Renombrado de tokenUrl a defaultTokenUrl para mayor claridad\n        this.defaultTokenUrl \u003d config.getKeycloakTokenUrl();\n        this.clientId \u003d config.getKeycloakClientId();\n        this.clientSecret \u003d config.getKeycloakClientSecret();\n        this.userInfoUrl \u003d config.getKeycloakUserInfoUrl();\n    }\n\n    public static AuthClient getInstance() {\n        if (instance \u003d\u003d null) {\n            synchronized (AuthClient.class) {\n                if (instance \u003d\u003d null) {\n                    instance \u003d new AuthClient();\n                }\n            }\n        }\n        return instance;\n    }\n\n    /**\n     * --- MÉTODO ANTIGUO (MODIFICADO) ---\n     * Realiza la petición al token endpoint POR DEFECTO (realm \u0027taller\u0027).\n     * Ahora delega la llamada al nuevo método sobrecargado.\n     */\n    public Response requestTokenResponse(String username, String password) {\n        log.debug(\"Solicitando token (por defecto) para user\u003d{}\", username);\n        // Llama al método de trabajo principal usando la URL por defecto\n        return requestTokenResponse(username, password, this.defaultTokenUrl);\n    }\n\n    /**\n     * --- MÉTODO NUEVO (SOBRECARGADO) ---\n     * Esta es la corrección clave.\n     * Realiza la petición al token endpoint en una URL ESPECÍFICA.\n     * Lo usaremos para llamar al realm \u0027master\u0027 cuando pidamos el token de admin.\n     */\n    public Response requestTokenResponse(String username, String password, String specificTokenUrl) {\n        log.debug(\"Solicitando token para user\u003d{} en URL\u003d{}\", username, specificTokenUrl);\n\n        Response response \u003d given()\n                // Corregido: RestAssured recomienda ContentType.URLENC\n                .contentType(ContentType.URLENC)\n                .formParam(\"grant_type\", \"password\")\n                .formParam(\"client_id\", clientId)\n                .formParam(\"client_secret\", clientSecret)\n                .formParam(\"username\", username)\n                .formParam(\"password\", password)\n                .when()\n                .post(specificTokenUrl); // \u003c-- Usa la URL específica",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 57
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/AuthClient.java",
      "timestamp": 1763022232154,
      "startOffset": 512,
      "endOffset": 2875,
      "codeContent": "\n    // Estos son los valores por DEFECTO (para el realm \u0027taller\u0027)\n    private final String defaultTokenUrl;\n    private final String clientId;\n    private final String clientSecret;\n    private final String userInfoUrl;\n\n    private AuthClient() {\n        TestConfig config \u003d TestConfig.getInstance();\n        // Renombrado de tokenUrl a defaultTokenUrl para mayor claridad\n        this.defaultTokenUrl \u003d config.getKeycloakTokenUrl();\n        this.clientId \u003d config.getKeycloakClientId();\n        this.clientSecret \u003d config.getKeycloakClientSecret();\n        this.userInfoUrl \u003d config.getKeycloakUserInfoUrl();\n    }\n\n    public static AuthClient getInstance() {\n        if (instance \u003d\u003d null) {\n            synchronized (AuthClient.class) {\n                if (instance \u003d\u003d null) {\n                    instance \u003d new AuthClient();\n                }\n            }\n        }\n        return instance;\n    }\n\n    /**\n     * --- MÉTODO ANTIGUO (MODIFICADO) ---\n     * Realiza la petición al token endpoint POR DEFECTO (realm \u0027taller\u0027).\n     * Ahora delega la llamada al nuevo método sobrecargado.\n     */\n    public Response requestTokenResponse(String username, String password) {\n        log.debug(\"Solicitando token (por defecto) para user\u003d{}\", username);\n        // Llama al método de trabajo principal usando la URL por defecto\n        return requestTokenResponse(username, password, this.defaultTokenUrl);\n    }\n\n    /**\n     * --- MÉTODO NUEVO (SOBRECARGADO) ---\n     * Esta es la corrección clave.\n     * Realiza la petición al token endpoint en una URL ESPECÍFICA.\n     * Lo usaremos para llamar al realm \u0027master\u0027 cuando pidamos el token de admin.\n     */\n    public Response requestTokenResponse(String username, String password, String specificTokenUrl) {\n        log.debug(\"Solicitando token para user\u003d{} en URL\u003d{}\", username, specificTokenUrl);\n\n        Response response \u003d given()\n                // Corregido: RestAssured recomienda ContentType.URLENC\n                .contentType(ContentType.URLENC)\n                .formParam(\"grant_type\", \"password\")\n                .formParam(\"client_id\", clientId)\n                .formParam(\"client_secret\", clientSecret)\n                .formParam(\"username\", username)\n                .formParam(\"password\", password)\n                .when()\n                .post(specificTokenUrl); // \u003c-- Usa la URL específica",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 57
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/AuthClient.java",
      "timestamp": 1763022268567,
      "startOffset": 231,
      "endOffset": 252,
      "codeContent": "import java.util.Map;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/AuthClient.java",
      "timestamp": 1763022270072,
      "startOffset": 231,
      "endOffset": 256,
      "codeContent": "import java.util.HashMap;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "/AuthClient.java",
      "timestamp": 1763022296496,
      "startOffset": 843,
      "endOffset": 891,
      "codeContent": "co.edu.uniquindio.tests.config.TestConfig config",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "/AuthClient.java",
      "timestamp": 1763022296503,
      "startOffset": 863,
      "endOffset": 884,
      "codeContent": "this.config \u003d config;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/AuthClient.java",
      "timestamp": 1763022296526,
      "startOffset": 863,
      "endOffset": 893,
      "codeContent": "\n        this.config \u003d config;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 2
    },
    {
      "filePath": "/_Dummy_.java",
      "timestamp": 1763022300377,
      "startOffset": 38,
      "endOffset": 86,
      "codeContent": "co.edu.uniquindio.tests.config.TestConfig config",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/AuthClient.java",
      "timestamp": 1763022381089,
      "startOffset": 140,
      "endOffset": 4587,
      "codeContent": "io.restassured.http.ContentType; // Importa ContentType\nimport lombok.extern.slf4j.Slf4j;\n\nimport static io.restassured.RestAssured.given;\n\n/**\n * Cliente encargado de manejar la autenticación y obtener información del usuario\n * desde Keycloak (u otro servidor compatible con OpenID Connect).\n */\n@Slf4j\npublic class AuthClient {\n\n    private static AuthClient instance;\n\n    // Estos son los valores por DEFECTO (para el realm \u0027taller\u0027)\n    private final String defaultTokenUrl;\n    private final String clientId;\n    private final String clientSecret;\n    private final String userInfoUrl;\n\n    private AuthClient() {\n        TestConfig config \u003d TestConfig.getInstance();\n        // Renombrado de tokenUrl a defaultTokenUrl para mayor claridad\n        this.defaultTokenUrl \u003d config.getKeycloakTokenUrl(); \n        this.clientId \u003d config.getKeycloakClientId();\n        this.clientSecret \u003d config.getKeycloakClientSecret();\n        this.userInfoUrl \u003d config.getKeycloakUserInfoUrl();\n    }\n\n    public static AuthClient getInstance() {\n        if (instance \u003d\u003d null) {\n            synchronized (AuthClient.class) {\n                if (instance \u003d\u003d null) {\n                    instance \u003d new AuthClient();\n                }\n            }\n        }\n        return instance;\n    }\n\n    /**\n     * --- MÉTODO ANTIGUO (MODIFICADO) ---\n     * Realiza la petición al token endpoint POR DEFECTO (realm \u0027taller\u0027).\n     * Ahora delega la llamada al nuevo método sobrecargado.\n     */\n    public Response requestTokenResponse(String username, String password) {\n        log.debug(\"Solicitando token (por defecto) para user\u003d{}\", username);\n        // Llama al método de trabajo principal usando la URL por defecto\n        return requestTokenResponse(username, password, this.defaultTokenUrl);\n    }\n\n    /**\n     * --- MÉTODO NUEVO (SOBRECARGADO) ---\n     * Esta es la corrección clave.\n     * Realiza la petición al token endpoint en una URL ESPECÍFICA.\n     * Lo usaremos para llamar al realm \u0027master\u0027 cuando pidamos el token de admin.\n     */\n    public Response requestTokenResponse(String username, String password, String specificTokenUrl) {\n        log.debug(\"Solicitando token para user\u003d{} en URL\u003d{}\", username, specificTokenUrl);\n\n        Response response \u003d given()\n                // Corregido: RestAssured recomienda ContentType.URLENC\n                .contentType(ContentType.URLENC) \n                .formParam(\"grant_type\", \"password\")\n                .formParam(\"client_id\", clientId)\n                .formParam(\"client_secret\", clientSecret)\n                .formParam(\"username\", username)\n                .formParam(\"password\", password)\n                .when()\n                .post(specificTokenUrl); // \u003c-- Usa la URL específica\n\n        log.debug(\"Token endpoint → status\u003d{} body\u003d{}\",\n                response.statusCode(), safeBody(response));\n\n        return response;\n    }\n\n\n    /**\n     * Obtiene el access_token y lanza excepción si la respuesta no es exitosa.\n     * (Este método no cambia, seguirá usando el realm por defecto \u0027taller\u0027)\n     */\n    public String getAccessToken(String username, String password) {\n        Response r \u003d requestTokenResponse(username, password); // Llama al método por defecto\n        if (r.statusCode() !\u003d 200) {\n            log.error(\"Error obteniendo token. Status: {}, Body: {}\", r.statusCode(), safeBody(r));\n            throw new RuntimeException(\"No se pudo obtener el token de acceso. Status: \" + r.statusCode());\n        }\n        String token \u003d r.jsonPath().getString(\"access_token\");\n        log.debug(\"Token obtenido correctamente para {} ({} caracteres)\", username, token !\u003d null ? token.length() : 0);\n        return token;\n    }\n\n    /**\n     * Llama al endpoint userinfo con el token proporcionado.\n     * (Este método no cambia)\n     */\n    public Response getUserInfo(String accessToken) {\n        log.debug(\"Llamando al endpoint userinfo\");\n        Response response \u003d given()\n                .header(\"Authorization\", \"Bearer \" + accessToken)\n                .when()\n                .get(userInfoUrl);\n\n        log.debug(\"Userinfo → status\u003d{} body\u003d{}\", response.statusCode(), safeBody(response));\n        return response;\n    }\n\n    private String safeBody(Response response) {\n        try {\n            return response.getBody() !\u003d null ? response.getBody().asString() : \"(sin cuerpo)\";\n        } catch (Exception e) {\n            return \"(error leyendo body)\";\n        }\n    }\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 116
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/TokenClient.java",
      "timestamp": 1763071235401,
      "startOffset": 2464,
      "endOffset": 4841,
      "codeContent": "                \n                tokenCache.put(cacheKey, new TokenInfo(newToken, expiresIn));\n                log.debug(\"Nuevo token guardado en caché para {} (expira en {}s)\", username, expiresIn);\n                return newToken;\n            } else {\n                log.warn(\"No se obtuvo token (status {}). Body: {}\", response.statusCode(), response.getBody().asString());\n                return null;\n            }\n        } catch (Exception e) {\n            log.error(\"Error al solicitar token para {}: {}\", username, e.getMessage());\n            throw new RuntimeException(\"Error al comunicarse con Keycloak: \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Obtiene el token del usuario administrador configurado en TestConfig.\n     * --- MÉTODO CORREGIDO ---\n     * Llama al realm \u0027master\u0027 con el client_id \u0027admin-cli\u0027 y sin secret.\n     */\n    public String getAdminToken() {\n        String cacheKey \u003d \"admin_master_token\"; // Clave de caché específica\n        TokenInfo tokenInfo \u003d tokenCache.get(cacheKey);\n\n        if (tokenInfo !\u003d null \u0026\u0026 !tokenInfo.isExpired()) {\n            log.debug(\"Reutilizando token de admin en caché\");\n            return tokenInfo.getAccessToken();\n        }\n\n        log.debug(\"Solicitando nuevo token de admin al realm \u0027master\u0027\");\n        String newToken;\n        int expiresIn \u003d 240; // fallback\n\n        try {\n            // Obtenemos las URLs y credenciales CORRECTAS\n            String masterTokenUrl \u003d config.getMasterTokenUrl(); // http://.../master/...\n            String adminClientId \u003d config.getAdminClientId();   // \"admin-cli\"\n\n            // Llamamos al método de AuthClient que lo soporta\n            Response response \u003d authClient.requestTokenResponse(\n                    config.getAdminUsername(),    // \"admin\"\n                    config.getAdminPassword(),    // \"admin123\"\n                    masterTokenUrl,               // URL del realm master\n                    adminClientId,                // \"admin-cli\"\n                    null                          // Sin client secret\n            );\n\n            if (response.statusCode() \u003d\u003d 200) {\n                newToken \u003d response.jsonPath().getString(\"access_token\");\n                Integer exp \u003d response.jsonPath().getInt(\"expires_in\");\n\n                if (exp !\u003d null \u0026\u0026 exp \u003e 0) {\n                    expiresIn \u003d exp;\n                }\n                ",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 54
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/ApiGatewayApplication.java",
      "timestamp": 1763076989977,
      "startOffset": 156,
      "endOffset": 404,
      "codeContent": "// Descomenta esta línea si usas Eureka o Consul. Si no, no es necesaria.\n// import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n\n@SpringBootApplication\n// @EnableDiscoveryClient // Opcional, dependiendo de tu service discovery",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 5
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/support/TokenClient.java",
      "timestamp": 1763079275989,
      "startOffset": 307,
      "endOffset": 6048,
      "codeContent": "@Slf4j\n@Getter\npublic class TokenClient {\n\n    private static TokenClient instance;\n\n    private final TestConfig config;\n    private final AuthClient authClient;\n    private final ConcurrentMap\u003cString, TokenInfo\u003e tokenCache;\n\n    private TokenClient() {\n        this.config \u003d TestConfig.getInstance();\n        this.authClient \u003d AuthClient.getInstance();\n        this.tokenCache \u003d new ConcurrentHashMap\u003c\u003e();\n    }\n\n    public static TokenClient getInstance() {\n        if (instance \u003d\u003d null) {\n            synchronized (TokenClient.class) {\n                if (instance \u003d\u003d null) {\n                    instance \u003d new TokenClient();\n                }\n            }\n        }\n        return instance;\n    }\n\n    // Metodo para obtener el token de cualquier usuario\n    public String getTokenForUser(String username, String password) {\n        return getToken(username, password);\n        // Reusa la lógica interna\n    }\n\n    /**\n     * Obtiene un token de acceso para un usuario (del realm \u0027taller\u0027),\n     * usando la caché si aún no expiró.\n     */\n    public String getToken(String username, String password) {\n        String cacheKey \u003d username;\n        TokenInfo tokenInfo \u003d tokenCache.get(cacheKey);\n\n        if (tokenInfo !\u003d null \u0026\u0026 !tokenInfo.isExpired()) {\n            log.debug(\"Reutilizando token en caché para usuario {}\", username);\n            return tokenInfo.getAccessToken();\n        }\n\n        log.debug(\"Solicitando nuevo token para usuario {}\", username);\n        String newToken;\n        int expiresIn \u003d 240; // fallback (4 min)\n\n        try {\n            // Llama al método por defecto de AuthClient (que usa realm \u0027taller\u0027)\n            Response response \u003d authClient.requestTokenResponse(username, password);\n            if (response.statusCode() \u003d\u003d 200) {\n                newToken \u003d response.jsonPath().getString(\"access_token\");\n                Integer exp \u003d response.jsonPath().getInt(\"expires_in\");\n\n                if (exp !\u003d null \u0026\u0026 exp \u003e 0) {\n                    expiresIn \u003d exp;\n                }\n\n                tokenCache.put(cacheKey, new TokenInfo(newToken, expiresIn));\n                log.debug(\"Nuevo token guardado en caché para {} (expira en {}s)\", username, expiresIn);\n                return newToken;\n            } else {\n                log.warn(\"No se obtuvo token (status {}). Body: {}\", response.statusCode(), response.getBody().asString());\n                return null;\n            }\n        } catch (Exception e) {\n            log.error(\"Error al solicitar token para {}: {}\", username, e.getMessage());\n            throw new RuntimeException(\"Error al comunicarse con Keycloak: \" + e.getMessage(), e);\n        }\n    }\n\n    /**\n     * Obtiene el token del usuario administrador configurado en TestConfig.\n     * --- MÉTODO CORREGIDO ---\n     * Llama al realm \u0027taller\u0027 (NO a \u0027master\u0027) con el client_id \u0027admin-cli\u0027.\n     */\n    public String getAdminToken() {\n        // Usamos una clave de caché diferente para el token de admin\n        String cacheKey \u003d config.getAdminUsername() + \"_admin_token\";\n        TokenInfo tokenInfo \u003d tokenCache.get(cacheKey);\n\n        if (tokenInfo !\u003d null \u0026\u0026 !tokenInfo.isExpired()) {\n            log.debug(\"Reutilizando token de admin en caché\");\n            return tokenInfo.getAccessToken();\n        }\n\n        log.debug(\"Solicitando nuevo token de admin al realm \u0027{}\u0027\", config.getKeycloakRealm());\n        String newToken;\n        int expiresIn \u003d 240; // fallback\n\n        try {\n            // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n            // ⬇️⬇️⬇️ INICIO DE LA CORRECCIÓN ⬇️⬇️⬇️\n            // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n            // Usamos la URL del realm \u0027taller\u0027, NO la del realm \u0027master\u0027\n            String tallerTokenUrl \u003d config.getKeycloakTokenUrl();\n            String adminClientId \u003d config.getAdminClientId();\n\n            // Llamamos al método de AuthClient que lo soporta\n            Response response \u003d authClient.requestTokenResponse(\n                    config.getAdminUsername(),    // \"admin\"\n                    config.getAdminPassword(),    // \"admin123\"\n                    tallerTokenUrl,               // URL del realm \u0027taller\u0027\n                    adminClientId,                // \"admin-cli\"\n                    null                          // Sin client secret\n            );\n            \n            // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n            // ⬆️⬆️⬆️ FIN DE LA CORRECCIÓN ⬆️⬆️⬆️\n            // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n            if (response.statusCode() \u003d\u003d 200) {\n                newToken \u003d response.jsonPath().getString(\"access_token\");\n                Integer exp \u003d response.jsonPath().getInt(\"expires_in\");\n\n                if (exp !\u003d null \u0026\u0026 exp \u003e 0) {\n                    expiresIn \u003d exp;\n                }\n\n                tokenCache.put(cacheKey, new TokenInfo(newToken, expiresIn));\n                log.debug(\"Nuevo token de ADMIN guardado en caché (expira en {}s)\", expiresIn);\n                return newToken;\n            } else {\n                log.error(\"¡FALLO CRÍTICO! No se pudo obtener el token de administrador.\");\n                log.error(\"El realm \u0027{}\u0027 de Keycloak en {} respondió con status {}. Body: {}\",\n                        config.getKeycloakRealm(), tallerTokenUrl, response.statusCode(), response.getBody().asString());\n                throw new RuntimeException(\"No se pudo obtener el token de administrador. Revisa la configuración.\");\n            }\n        } catch (Exception e) {\n            log.error(\"Error al solicitar token de admin: {}\", e.getMessage());\n            throw new RuntimeException(\"Error al comunicarse con Keycloak (admin",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 135
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/hooks/Hooks.java",
      "timestamp": 1763112024797,
      "startOffset": 705,
      "endOffset": 1228,
      "codeContent": "log.info(\"CONFIG RESUELTA:\");\nlog.info(\" - apiBaseUrl \u003d {}\", config.getApiBaseUrl());\nlog.info(\" - keycloakUrl \u003d {}\", config.getKeycloakUrl());\nlog.info(\" - keycloakTokenUrl \u003d {}\", config.getKeycloakTokenUrl());\n// Intenta obtener token admin sin lanzar (solo loguear)\ntry {\n    String t \u003d tokenClient.getAdminToken();\n    log.info(\" - admin token obtenido (longitud): {}\", t !\u003d null ? t.length() : \"null\");\n} catch (Exception e) {\n    log.warn(\" - No se pudo obtener token admin en beforeScenario: {}\", e.getMessage());\n}\n",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 12
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/hooks/Hooks.java",
      "timestamp": 1763112953547,
      "startOffset": 1370,
      "endOffset": 1402,
      "codeContent": "co.edu.uniquindio.tests.support.",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/test-automation/src/test/java/co/edu/uniquindio/tests/hooks/Hooks.java",
      "timestamp": 1763112953561,
      "startOffset": 90,
      "endOffset": 145,
      "codeContent": "import co.edu.uniquindio.tests.support.ScenarioContext;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/controller/PerfilController.java",
      "timestamp": 1763139141779,
      "startOffset": 2997,
      "endOffset": 4011,
      "codeContent": "/**\n     * Endpoint para que el Gateway (u otro admin) obtenga un perfil por ID de usuario.\n     * En una app real, esto buscaría en un PerfilRepository.\n     */\n    @GetMapping(\"/por-usuario/{userId}\")\n    public ResponseEntity\u003cPerfilResponse\u003e obtenerPerfilPorUsuarioId(@PathVariable UUID userId) {\n        // --- STUB (Simulación) ---\n        // En una implementación real, aquí llamarías a:\n        // Perfil perfil \u003d perfilService.obtenerPorUsuarioId(userId);\n        // y construirías la respuesta.\n        \n        // Devolvemos datos dummy para que la agregación funcione:\n        PerfilRequest dummyRequest \u003d new PerfilRequest();\n        dummyRequest.setApodo(\"PerfilStub-\" + userId.toString().substring(0, 4));\n        dummyRequest.setBiografia(\"Biografía de prueba para el usuario \" + userId);\n        dummyRequest.setPaisResidencia(\"Colombia\");\n\n        PerfilResponse response \u003d new PerfilResponse(userId, dummyRequest);\n        return ResponseEntity.ok(response);\n        // --- Fin del STUB ---\n    }",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 21
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/ApiGatewayApplication.java",
      "timestamp": 1763139303498,
      "startOffset": 229,
      "endOffset": 1005,
      "codeContent": "import org.springframework.context.annotation.Bean; // Importar\nimport org.springframework.web.reactive.function.client.WebClient; // Importar\n\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class ApiGatewayApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ApiGatewayApplication.class, args);\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    // ⬇️⬇️⬇️ BEAN NUEVO REQUERIDO ⬇️⬇️⬇️\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    /**\n     * Provee un builder de WebClient para que los controladores\n     * y servicios puedan inyectarlo y hacer llamadas HTTP.\n     */\n    @Bean\n    public WebClient.Builder webClientBuilder() {\n        return WebClient.builder();\n    }",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 22
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/dto/UsuarioResponse.java",
      "timestamp": 1763139355826,
      "startOffset": 0,
      "endOffset": 73,
      "codeContent": "package co.edu.uniquindio.gateway.dto;\n\npublic class UsuarioResponse {\n}\n",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 5
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/dto/UsuarioResponse.java",
      "timestamp": 1763139363822,
      "startOffset": 40,
      "endOffset": 659,
      "codeContent": "import java.util.UUID;\n\n// DTO espejo de co.edu.uniquindio.tallerapi2.dto.UsuarioResponse\n// Necesario para que el Gateway pueda deserializar la respuesta del microservicio\npublic class UsuarioResponse {\n    private UUID id;\n    private String nombre;\n    private String email;\n\n    // Getters y Setters\n    public UUID getId() { return id; }\n    public void setId(UUID id) { this.id \u003d id; }\n    public String getNombre() { return nombre; }\n    public void setNombre(String nombre) { this.nombre \u003d nombre; }\n    public String getEmail() { return email; }\n    public void setEmail(String email) { this.email \u003d email; }\n}",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 17
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/dto/PerfilResponse.java",
      "timestamp": 1763139383675,
      "startOffset": 0,
      "endOffset": 72,
      "codeContent": "package co.edu.uniquindio.gateway.dto;\n\npublic class PerfilResponse {\n}\n",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 5
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/dto/PerfilResponse.java",
      "timestamp": 1763139389152,
      "startOffset": 40,
      "endOffset": 1853,
      "codeContent": "import java.util.Map;\nimport java.util.UUID;\n\n// DTO espejo de co.edu.uniquindio.tallerapi2.dto.PerfilResponse\npublic class PerfilResponse {\n    private UUID userId;\n    private String apodo;\n    private String biografia;\n    private String paginaPersonal;\n    private String direccion;\n    private String organizacion;\n    private String paisResidencia;\n    private Boolean informacionPublica;\n    private Map\u003cString, String\u003e redesSociales;\n\n    // Getters y Setters\n    public UUID getUserId() { return userId; }\n    public void setUserId(UUID userId) { this.userId \u003d userId; }\n    public String getApodo() { return apodo; }\n    public void setApodo(String apodo) { this.apodo \u003d apodo; }\n    public String getBiografia() { return biografia; }\n    public void setBiografia(String biografia) { this.biografia \u003d biografia; }\n    public String getPaginaPersonal() { return paginaPersonal; }\n    public void setPaginaPersonal(String paginaPersonal) { this.paginaPersonal \u003d paginaPersonal; }\n    public String getDireccion() { return direccion; }\n    public void setDireccion(String direccion) { this.direccion \u003d direccion; }\n    public String getOrganizacion() { return organizacion; }\n    public void setOrganizacion(String organizacion) { this.organizacion \u003d organizacion; }\n    public String getPaisResidencia() { return paisResidencia; }\n    public void setPaisResidencia(String paisResidencia) { this.paisResidencia \u003d paisResidencia; }\n    public Boolean getInformacionPublica() { return informacionPublica; }\n    public void setInformacionPublica(Boolean informacionPublica) { this.informacionPublica \u003d informacionPublica; }\n    public Map\u003cString, String\u003e getRedesSociales() { return redesSociales; }\n    public void setRedesSociales(Map\u003cString, String\u003e redesSociales) { this.redesSociales \u003d redesSociales; }\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 35
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/dto/UsuarioCompletoResponse.java",
      "timestamp": 1763139411973,
      "startOffset": 0,
      "endOffset": 81,
      "codeContent": "package co.edu.uniquindio.gateway.dto;\n\npublic class UsuarioCompletoResponse {\n}\n",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 5
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/dto/UsuarioCompletoResponse.java",
      "timestamp": 1763139417284,
      "startOffset": 40,
      "endOffset": 713,
      "codeContent": "// DTO de Agregación. Contiene la información de ambos servicios.\npublic class UsuarioCompletoResponse {\n    \n    private UsuarioResponse usuario;\n    private PerfilResponse perfil;\n\n    // Constructor para la agregación\n    public UsuarioCompletoResponse(UsuarioResponse usuario, PerfilResponse perfil) {\n        this.usuario \u003d usuario;\n        this.perfil \u003d perfil;\n    }\n\n    // Getters y Setters\n    public UsuarioResponse getUsuario() { return usuario; }\n    public void setUsuario(UsuarioResponse usuario) { this.usuario \u003d usuario; }\n    public PerfilResponse getPerfil() { return perfil; }\n    public void setPerfil(PerfilResponse perfil) { this.perfil \u003d perfil; }\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 18
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/controller/UsuarioAgregadoController.java",
      "timestamp": 1763139451879,
      "startOffset": 0,
      "endOffset": 90,
      "codeContent": "package co.edu.uniquindio.gateway.controller;\n\npublic class UsuarioAgregadoController {\n}\n",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 5
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/api-gateway/src/main/java/co/edu/uniquindio/gateway/controller/UsuarioAgregadoController.java",
      "timestamp": 1763139456234,
      "startOffset": 47,
      "endOffset": 3239,
      "codeContent": "import co.edu.uniquindio.gateway.dto.PerfilResponse;\nimport co.edu.uniquindio.gateway.dto.UsuarioCompletoResponse;\nimport co.edu.uniquindio.gateway.dto.UsuarioResponse;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.reactive.function.client.WebClient;\nimport org.springframework.web.server.ResponseStatusException;\nimport reactor.core.publisher.Mono;\n\nimport java.util.UUID;\n\n@RestController\n@RequestMapping(\"/api/usuario-completo\")\npublic class UsuarioAgregadoController {\n\n    private final WebClient webClientTallerApi;\n\n    public UsuarioAgregadoController(WebClient.Builder webClientBuilder) {\n        // Creamos un WebClient que apunta al servicio \u0027taller-api-2\u0027\n        // \u0027taller-api-2\u0027 es el nombre del servicio en docker-compose.yml\n        this.webClientTallerApi \u003d webClientBuilder\n                .baseUrl(\"http://taller-api-2:8080\")\n                .build();\n    }\n\n    /**\n     * Implementa el requisito R6d:\n     * 1. Recibe una solicitud de \"datos completos\".\n     * 2. Divide la solicitud en dos llamadas (Fan-out).\n     * 3. Unifica las respuestas (Fan-in).\n     * 4. Devuelve una respuesta unificada.\n     */\n    @GetMapping(\"/{id}\")\n    public Mono\u003cResponseEntity\u003cUsuarioCompletoResponse\u003e\u003e getUsuarioCompleto(\n            @PathVariable String id,\n            @RequestHeader(HttpHeaders.AUTHORIZATION) String authorizationHeader) {\n\n        // 1. (Fan-out) Preparamos la llamada al endpoint de Usuarios\n        Mono\u003cUsuarioResponse\u003e usuarioMono \u003d webClientTallerApi.get()\n                .uri(\"/api/usuarios/\" + id)\n                .header(HttpHeaders.AUTHORIZATION, authorizationHeader) // Pasar el token\n                .retrieve()\n                // Si el usuario no existe, lanzamos un 404\n                .onStatus(\n                        status -\u003e status \u003d\u003d HttpStatus.NOT_FOUND,\n                        clientResponse -\u003e Mono.error(new ResponseStatusException(HttpStatus.NOT_FOUND, \"Usuario no encontrado\"))\n                )\n                .bodyToMono(UsuarioResponse.class);\n\n        // 2. (Fan-out) Preparamos la llamada al endpoint de Perfiles\n        Mono\u003cPerfilResponse\u003e perfilMono \u003d webClientTallerApi.get()\n                .uri(\"/api/perfiles/por-usuario/\" + id)\n                .header(HttpHeaders.AUTHORIZATION, authorizationHeader) // Pasar el token\n                .retrieve()\n                .bodyToMono(PerfilResponse.class)\n                // Si el perfil no existe (404) o da error, simplemente devolvemos un objeto vacío\n                .onErrorResume(e -\u003e Mono.just(new PerfilResponse())); \n\n        // 3. (Fan-in) Combinamos ambas respuestas cuando estén listas\n        return Mono.zip(usuarioMono, perfilMono)\n                .map(tupla -\u003e {\n                    // tupla.getT1() es la respuesta de usuarioMono\n                    // tupla.getT2() es la respuesta de perfilMono\n                    return new UsuarioCompletoResponse(tupla.getT1(), tupla.getT2());\n                })\n                .map(respuestaUnificada -\u003e ResponseEntity.ok(respuestaUnificada));\n    }\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 70
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/dto/events/UsuarioEliminadoEvent.java",
      "timestamp": 1763139554491,
      "startOffset": 0,
      "endOffset": 89,
      "codeContent": "package co.edu.uniquindio.tallerapi2.dto.events;\n\npublic class UsuarioEliminadoEvent {\n}\n",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 5
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/dto/events/UsuarioEliminadoEvent.java",
      "timestamp": 1763139559600,
      "startOffset": 50,
      "endOffset": 1308,
      "codeContent": "import com.fasterxml.jackson.annotation.JsonFormat;\nimport java.time.LocalDateTime;\nimport java.util.UUID;\n\n// DTO para el evento de usuario eliminado\npublic class UsuarioEliminadoEvent {\n\n    private UUID usuarioId;\n    private String email;\n    \n    @JsonFormat(shape \u003d JsonFormat.Shape.STRING, pattern \u003d \"yyyy-MM-dd\u0027T\u0027HH:mm:ss\")\n    private LocalDateTime timestamp;\n\n    private String eventType;\n\n    // Constructores\n    public UsuarioEliminadoEvent() {\n        this.timestamp \u003d LocalDateTime.now();\n        this.eventType \u003d \"USUARIO_ELIMINADO\";\n    }\n\n    public UsuarioEliminadoEvent(UUID usuarioId, String email) {\n        this();\n        this.usuarioId \u003d usuarioId;\n        this.email \u003d email;\n    }\n\n    // Getters y Setters\n    public UUID getUsuarioId() { return usuarioId; }\n    public void setUsuarioId(UUID usuarioId) { this.usuarioId \u003d usuarioId; }\n    public String getEmail() { return email; }\n    public void setEmail(String email) { this.email \u003d email; }\n    public LocalDateTime getTimestamp() { return timestamp; }\n    public void setTimestamp(LocalDateTime timestamp) { this.timestamp \u003d timestamp; }\n    public String getEventType() { return eventType; }\n    public void setEventType(String eventType) { this.eventType \u003d eventType; }\n}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 37
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139620719,
      "startOffset": 623,
      "endOffset": 672,
      "codeContent": "private Eliminados eliminados \u003d new Eliminados();",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139689838,
      "startOffset": 46,
      "endOffset": 4482,
      "codeContent": "// ... (imports) ...\n// ⬇️ Importar el nuevo DTO de evento ⬇️\nimport co.edu.uniquindio.tallerapi2.dto.events.UsuarioEliminadoEvent; \n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Configuration\npublic class RabbitMQConfig {\n\n    private final AppRabbitMQProperties properties;\n\n    public RabbitMQConfig(AppRabbitMQProperties properties) {\n        this.properties \u003d properties;\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d EXCHANGE \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    @Bean\n    public TopicExchange appExchange() {\n        return new TopicExchange(properties.getExchange());\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d QUEUES \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    @Bean\n    public Queue usuariosQueue() {\n        return new Queue(properties.getUsuarios().getQueue(), true);\n    }\n\n    @Bean\n    public Queue sesionesQueue() {\n        return new Queue(properties.getSesiones().getQueue(), true);\n    }\n\n    @Bean\n    public Queue passwordQueue() {\n        return new Queue(properties.getPassword().getQueue(), true);\n    }\n\n    // ⬇️ --- AÑADIR NUEVO BEAN DE COLA --- ⬇️\n    @Bean\n    public Queue usuariosEliminadosQueue() {\n        return new Queue(properties.getUsuarios().getEliminados().getQueue(), true);\n    }\n    // ⬆️ --- FIN DE LO AÑADIDO --- ⬆️\n\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d BINDINGS \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    @Bean\n    public Binding usuariosBinding(Queue usuariosQueue, TopicExchange appExchange) {\n        return BindingBuilder.bind(usuariosQueue)\n                .to(appExchange)\n                .with(properties.getUsuarios().getRoutingKey());\n    }\n\n    @Bean\n    public Binding sesionesBinding(Queue sesionesQueue, TopicExchange appExchange) {\n        return BindingBuilder.bind(sesionesQueue)\n                .to(appExchange)\n                .with(properties.getSesiones().getRoutingKey());\n    }\n\n    @Bean\n    public Binding passwordBinding(Queue passwordQueue, TopicExchange appExchange) {\n        return BindingBuilder.bind(passwordQueue)\n                .to(appExchange)\n                .with(properties.getPassword().getRoutingKey());\n    }\n\n    // ⬇️ --- AÑADIR NUEVO BEAN DE BINDING --- ⬇️\n    @Bean\n    public Binding usuariosEliminadosBinding(Queue usuariosEliminadosQueue, TopicExchange appExchange) {\n        return BindingBuilder.bind(usuariosEliminadosQueue)\n                .to(appExchange)\n                .with(properties.getUsuarios().getEliminados().getRoutingKey());\n    }\n    // ⬆️ --- FIN DE LO AÑADIDO --- ⬆️\n\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d MESSAGE CONVERTER \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    @Bean\n    public MessageConverter jsonMessageConverter() {\n        Jackson2JsonMessageConverter converter \u003d new Jackson2JsonMessageConverter();\n        DefaultClassMapper classMapper \u003d new DefaultClassMapper();\n        Map\u003cString, Class\u003c?\u003e\u003e idClassMapping \u003d new HashMap\u003c\u003e();\n        \n        idClassMapping.put(\"co.edu.uniquindio.tallerapi2.dto.events.UsuarioCreadoEvent\", UsuarioCreadoEvent.class);\n        idClassMapping.put(\"co.edu.uniquindio.tallerapi2.dto.events.SesionIniciadaEvent\", SesionIniciadaEvent.class);\n        idClassMapping.put(\"co.edu.uniquindio.tallerapi2.dto.events.PasswordResetSolicitadoEvent\", PasswordResetSolicitadoEvent.class);\n        idClassMapping.put(\"co.edu.uniquindio.tallerapi2.dto.events.PasswordActualizadoEvent\", PasswordActualizadoEvent.class);\n        \n        // ⬇️ --- AÑADIR MAPEADO DE CLASE DEL NUEVO EVENTO --- ⬇️\n        idClassMapping.put(\"co.edu.uniquindio.tallerapi2.dto.events.UsuarioEliminadoEvent\", UsuarioEliminadoEvent.class);\n        // ⬆️ --- FIN DE LO AÑADIDO --- ⬆️\n\n        classMapper.setIdClassMapping(idClassMapping);\n        converter.setClassMapper(classMapper);\n\n        return converter;\n    }\n\n    // ... (RabbitTemplate y ListenerFactory sin cambios) ...\n    @Bean\n    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory,\n                                         MessageConverter jsonMessageConverter) {\n        RabbitTemplate template \u003d new RabbitTemplate(connectionFactory);\n        template.setMessageConverter(jsonMessageConverter);\n        return template;\n    }\n\n    @Bean\n    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(ConnectionFactory connectionFactory,\n                                                                         MessageConverter jsonMessageConverter) {\n        SimpleRabbitListenerContainerFactory factory \u003d new SimpleRabbitListenerContainerFactory();\n        factory.setConnectionFactory(connectionFactory);\n        factory.setMessageConverter(jsonMessageConverter);\n        return factory",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 116
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139715668,
      "startOffset": 177,
      "endOffset": 237,
      "codeContent": "import org.springframework.context.annotation.Configuration;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139730389,
      "startOffset": 178,
      "endOffset": 229,
      "codeContent": "import org.springframework.context.annotation.Bean;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139751832,
      "startOffset": 275,
      "endOffset": 298,
      "codeContent": "import java.util.Queue;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139754825,
      "startOffset": 227,
      "endOffset": 288,
      "codeContent": "import org.springframework.context.annotation.Configuration;\n",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 2
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139756282,
      "startOffset": 743,
      "endOffset": 782,
      "codeContent": "org.springframework.context.annotation.",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139756910,
      "startOffset": 289,
      "endOffset": 328,
      "codeContent": "org.springframework.context.annotation.",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139770517,
      "startOffset": 46,
      "endOffset": 4482,
      "codeContent": "// ... (imports) ...\n// ⬇️ Importar el nuevo DTO de evento ⬇️\nimport co.edu.uniquindio.tallerapi2.dto.events.UsuarioEliminadoEvent; \n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Configuration\npublic class RabbitMQConfig {\n\n    private final AppRabbitMQProperties properties;\n\n    public RabbitMQConfig(AppRabbitMQProperties properties) {\n        this.properties \u003d properties;\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d EXCHANGE \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    @Bean\n    public TopicExchange appExchange() {\n        return new TopicExchange(properties.getExchange());\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d QUEUES \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    @Bean\n    public Queue usuariosQueue() {\n        return new Queue(properties.getUsuarios().getQueue(), true);\n    }\n\n    @Bean\n    public Queue sesionesQueue() {\n        return new Queue(properties.getSesiones().getQueue(), true);\n    }\n\n    @Bean\n    public Queue passwordQueue() {\n        return new Queue(properties.getPassword().getQueue(), true);\n    }\n\n    // ⬇️ --- AÑADIR NUEVO BEAN DE COLA --- ⬇️\n    @Bean\n    public Queue usuariosEliminadosQueue() {\n        return new Queue(properties.getUsuarios().getEliminados().getQueue(), true);\n    }\n    // ⬆️ --- FIN DE LO AÑADIDO --- ⬆️\n\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d BINDINGS \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    @Bean\n    public Binding usuariosBinding(Queue usuariosQueue, TopicExchange appExchange) {\n        return BindingBuilder.bind(usuariosQueue)\n                .to(appExchange)\n                .with(properties.getUsuarios().getRoutingKey());\n    }\n\n    @Bean\n    public Binding sesionesBinding(Queue sesionesQueue, TopicExchange appExchange) {\n        return BindingBuilder.bind(sesionesQueue)\n                .to(appExchange)\n                .with(properties.getSesiones().getRoutingKey());\n    }\n\n    @Bean\n    public Binding passwordBinding(Queue passwordQueue, TopicExchange appExchange) {\n        return BindingBuilder.bind(passwordQueue)\n                .to(appExchange)\n                .with(properties.getPassword().getRoutingKey());\n    }\n\n    // ⬇️ --- AÑADIR NUEVO BEAN DE BINDING --- ⬇️\n    @Bean\n    public Binding usuariosEliminadosBinding(Queue usuariosEliminadosQueue, TopicExchange appExchange) {\n        return BindingBuilder.bind(usuariosEliminadosQueue)\n                .to(appExchange)\n                .with(properties.getUsuarios().getEliminados().getRoutingKey());\n    }\n    // ⬆️ --- FIN DE LO AÑADIDO --- ⬆️\n\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d MESSAGE CONVERTER \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    @Bean\n    public MessageConverter jsonMessageConverter() {\n        Jackson2JsonMessageConverter converter \u003d new Jackson2JsonMessageConverter();\n        DefaultClassMapper classMapper \u003d new DefaultClassMapper();\n        Map\u003cString, Class\u003c?\u003e\u003e idClassMapping \u003d new HashMap\u003c\u003e();\n        \n        idClassMapping.put(\"co.edu.uniquindio.tallerapi2.dto.events.UsuarioCreadoEvent\", UsuarioCreadoEvent.class);\n        idClassMapping.put(\"co.edu.uniquindio.tallerapi2.dto.events.SesionIniciadaEvent\", SesionIniciadaEvent.class);\n        idClassMapping.put(\"co.edu.uniquindio.tallerapi2.dto.events.PasswordResetSolicitadoEvent\", PasswordResetSolicitadoEvent.class);\n        idClassMapping.put(\"co.edu.uniquindio.tallerapi2.dto.events.PasswordActualizadoEvent\", PasswordActualizadoEvent.class);\n        \n        // ⬇️ --- AÑADIR MAPEADO DE CLASE DEL NUEVO EVENTO --- ⬇️\n        idClassMapping.put(\"co.edu.uniquindio.tallerapi2.dto.events.UsuarioEliminadoEvent\", UsuarioEliminadoEvent.class);\n        // ⬆️ --- FIN DE LO AÑADIDO --- ⬆️\n\n        classMapper.setIdClassMapping(idClassMapping);\n        converter.setClassMapper(classMapper);\n\n        return converter;\n    }\n\n    // ... (RabbitTemplate y ListenerFactory sin cambios) ...\n    @Bean\n    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory,\n                                         MessageConverter jsonMessageConverter) {\n        RabbitTemplate template \u003d new RabbitTemplate(connectionFactory);\n        template.setMessageConverter(jsonMessageConverter);\n        return template;\n    }\n\n    @Bean\n    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(ConnectionFactory connectionFactory,\n                                                                         MessageConverter jsonMessageConverter) {\n        SimpleRabbitListenerContainerFactory factory \u003d new SimpleRabbitListenerContainerFactory();\n        factory.setConnectionFactory(connectionFactory);\n        factory.setMessageConverter(jsonMessageConverter);\n        return factory",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 116
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139788374,
      "startOffset": 122,
      "endOffset": 173,
      "codeContent": "import org.springframework.context.annotation.Bean;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139790332,
      "startOffset": 46,
      "endOffset": 97,
      "codeContent": "import org.springframework.amqp.core.TopicExchange;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139798605,
      "startOffset": 405,
      "endOffset": 428,
      "codeContent": "import java.util.Queue;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139803735,
      "startOffset": 671,
      "endOffset": 701,
      "codeContent": "org.springframework.amqp.core.",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763139804256,
      "startOffset": 603,
      "endOffset": 642,
      "codeContent": "org.springframework.context.annotation.",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/service/EventPublisherService.java",
      "timestamp": 1763139854680,
      "startOffset": 803,
      "endOffset": 872,
      "codeContent": "import co.edu.uniquindio.tallerapi2.dto.events.UsuarioEliminadoEvent;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/service/EventPublisherService.java",
      "timestamp": 1763139883534,
      "startOffset": 1705,
      "endOffset": 2406,
      "codeContent": "/**\n     * Publica evento de usuario eliminado\n     */\n    public void publishUsuarioEliminado(UsuarioEliminadoEvent event) {\n        try {\n            log.info(\"Publicando evento de usuario eliminado: {}\", event);\n            rabbitTemplate.convertAndSend(\n                    properties.getExchange(),\n                    properties.getUsuarios().getEliminados().getRoutingKey(), // Usamos el nuevo routing key\n                    event\n            );\n            log.info(\"Evento de eliminación publicado exitosamente para usuario: {}\", event.getEmail());\n        } catch (Exception e) {\n            log.error(\"Error al publicar evento de usuario eliminado: {}\", e.getMessage(), e);\n        }\n    }",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 16
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/controller/UsuarioController.java",
      "timestamp": 1763139928337,
      "startOffset": 1899,
      "endOffset": 1968,
      "codeContent": "import co.edu.uniquindio.tallerapi2.dto.events.UsuarioEliminadoEvent;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/RabbitMQConfig.java",
      "timestamp": 1763140236096,
      "startOffset": 1070,
      "endOffset": 1139,
      "codeContent": "import co.edu.uniquindio.tallerapi2.dto.events.UsuarioEliminadoEvent;",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 1
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763140493206,
      "startOffset": 514,
      "endOffset": 1269,
      "codeContent": "private Eliminados eliminados \u003d new Eliminados();\n        \n        // 2. Clase interna para la nueva configuración\n        public static class Eliminados {\n            private String queue;\n            private String routingKey;\n\n            public String getQueue() { return queue; }\n            public void setQueue(String queue) { this.queue \u003d queue; }\n            public String getRoutingKey() { return routingKey; }\n            public void setRoutingKey(String routingKey) { this.routingKey \u003d routingKey; }\n        }\n\n        // 3. Getters y Setters para el nuevo campo (¡ESTO ES LO QUE FALTA!)\n        public Eliminados getEliminados() { return eliminados; }\n        public void setEliminados(Eliminados eliminados) { this.eliminados \u003d eliminados; }",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 16
    },
    {
      "filePath": "C:/Users/holda/OneDrive/Documents/Documentos Universidad/2025-2/Microservicios/proyecto-final/taller-api-2/src/main/java/co/edu/uniquindio/tallerapi2/config/AppRabbitMQProperties.java",
      "timestamp": 1763140532832,
      "startOffset": 291,
      "endOffset": 4087,
      "codeContent": "private String exchange;\n    [cite_start]private Usuarios usuarios \u003d new Usuarios(); [cite: 563]\n    [cite_start]private Sesiones sesiones \u003d new Sesiones(); [cite: 563]\n    [cite_start]private Password password \u003d new Password(); [cite: 563]\n\n    // ⬇️ ESTA ES LA CLASE MODIFICADA ⬇️\n    public static class Usuarios {\n        [cite_start]private String queue; [cite: 564]\n        [cite_start]private String routingKey; [cite: 564]\n        \n        // --- INICIO DE LA MODIFICACIÓN ---\n        // 1. Campo para la nueva configuración\n        private Eliminados eliminados \u003d new Eliminados();\n        \n        // 2. Clase interna para la nueva configuración\n        public static class Eliminados {\n            private String queue;\n            private String routingKey;\n\n            public String getQueue() { return queue; }\n            public void setQueue(String queue) { this.queue \u003d queue; }\n            public String getRoutingKey() { return routingKey; }\n            public void setRoutingKey(String routingKey) { this.routingKey \u003d routingKey; }\n        }\n\n        // 3. Getters y Setters para el nuevo campo (¡ESTO ES LO QUE FALTA!)\n        public Eliminados getEliminados() { return eliminados; }\n        public void setEliminados(Eliminados eliminados) { this.eliminados \u003d eliminados; }\n        // --- FIN DE LA MODIFICACIÓN ---\n\n        // (Getters y Setters originales de Usuarios)\n        [cite_start]public String getQueue() { [cite: 565]\n            return queue;\n        }\n        [cite_start]public void setQueue(String queue) { [cite: 566]\n            this.queue \u003d queue;\n        }\n        [cite_start]public String getRoutingKey() { [cite: 567]\n            return routingKey;\n        }\n        [cite_start]public void setRoutingKey(String routingKey) { [cite: 568]\n            this.routingKey \u003d routingKey;\n        }\n    }\n    // ⬆️ FIN DE LA CLASE MODIFICADA ⬆️\n\n\n    // (Clases Sesiones y Password sin cambios)\n    public static class Sesiones {\n        [cite_start]private String queue; [cite: 569]\n        [cite_start]private String routingKey; [cite: 570]\n        public String getQueue() { return queue; [cite_start]} [cite: 570-571]\n        public void setQueue(String queue) { this.queue \u003d queue; [cite_start]} [cite: 571-572]\n        public String getRoutingKey() { return routingKey; [cite_start]} [cite: 572-573]\n        public void setRoutingKey(String routingKey) { this.routingKey \u003d routingKey; [cite_start]} [cite: 573-574]\n    }\n\n    public static class Password {\n        [cite_start]private String queue; [cite: 574-575]\n        [cite_start]private String routingKey; [cite: 575]\n        public String getQueue() { return queue; [cite_start]} [cite: 575-576]\n        public void setQueue(String queue) { this.queue \u003d queue; [cite_start]} [cite: 576-577]\n        public String getRoutingKey() { return routingKey; [cite_start]} [cite: 577-578]\n        public void setRoutingKey(String routingKey) { this.routingKey \u003d routingKey; [cite_start]} [cite: 578-579]\n    }\n\n    // (Getters y setters principales sin cambios)\n    public String getExchange() { return exchange; [cite_start]} [cite: 579]\n    public void setExchange(String exchange) { this.exchange \u003d exchange; [cite_start]} [cite: 580-581]\n    public Usuarios getUsuarios() { return usuarios; [cite_start]} [cite: 581-582]\n    public void setUsuarios(Usuarios usuarios) { this.usuarios \u003d usuarios; [cite_start]} [cite: 582-583]\n    public Sesiones getSesiones() { return sesiones; [cite_start]} [cite: 583-584]\n    public void setSesiones(Sesiones sesiones) { this.sesiones \u003d sesiones; [cite_start]} [cite: 584-585]\n    public Password getPassword() { return password; [cite_start]} [cite: 585-586]\n    public void setPassword(Password password) { this.password \u003d password; [cite_start]} [cite: 586-587]",
      "aiProbability": 70,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 75
    }
  ],
  "toolStats": {
    "GitHub Copilot": {
      "usageCount": 66,
      "totalLines": 1378
    }
  }
}